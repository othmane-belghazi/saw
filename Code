import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import pearsonr
from io import BytesIO

# Configuration de la page
st.set_page_config(
    page_title="Analyse des Atouts PRO",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Titre principal
st.title("üìä Analyse des Atouts PRO")
st.markdown("---")

# Fonctions utilitaires
@st.cache_data
def create_sample_data():
    """Cr√©er des donn√©es d'exemple pour d√©monstration"""
    np.random.seed(42)
    
    # G√©n√©ration des codes activit√©
    codes_activite = [f"ACT{i:03d}" for i in range(1, 101)]
    
    # Data ELR
    elr_data = pd.DataFrame({
        'Code activit√©': codes_activite,
        'Pol Formule': ['Atout PRO'] * 100,
        'Libell√©': [f'Activit√© {i}' for i in range(1, 101)],
        'Pourcentage ELR': np.random.uniform(5, 25, 100)
    })
    
    # Data Tarif Vendu
    tarif_data = pd.DataFrame({
        'Code_acti_ET100': codes_activite,
        'Produit': ['AtoutsPRO'] * 100,
        'FORMULE': ['Atout PRO'] * 100,
        'Nombre_AN24': np.random.randint(10, 500, 100),
        'Somme_tarif_vendu': np.random.uniform(50000, 2000000, 100),
        'Somme_tarif_vendu_SansFDR': lambda x: x * 0.95,
        'moyenne_tarif_vendu_HT': np.random.uniform(1000, 15000, 100),
        'moyenne_tarif_vendu_SansFDR': lambda x: x * 0.95
    })
    
    # Calcul des colonnes d√©riv√©es
    tarif_data['Somme_tarif_vendu_SansFDR'] = tarif_data['Somme_tarif_vendu'] * 0.95
    tarif_data['moyenne_tarif_vendu_SansFDR'] = tarif_data['moyenne_tarif_vendu_HT'] * 0.95
    
    # Data march√©
    marche_data = pd.DataFrame({
        'CodeActivite_AtoutsPro': codes_activite,
        'march√©_r√©el': np.random.choice(['Automobile', 'Habitation', 'Professionnel', 'Sant√©', 'Loisirs'], 100)
    })
    
    # Taux de concr√©tisation
    taux_data = pd.DataFrame({
        'Code': codes_activite,
        'Taux_Concretisation': np.random.uniform(0.15, 0.85, 100)
    })
    
    return elr_data, tarif_data, marche_data, taux_data

def create_segments(data, column, n_segments, prefix):
    """Cr√©er des segments bas√©s sur les quantiles"""
    quantiles = np.linspace(0, 1, n_segments + 1)
    segment_bounds = data[column].quantile(quantiles).values
    
    segments = []
    for i in range(n_segments):
        segments.append({
            'Groupe': f'{prefix}_{i+1:02d}',
            'Min': segment_bounds[i],
            'Max': segment_bounds[i+1]
        })
    
    return pd.DataFrame(segments)

def assign_segment(value, segments_df, min_col='Min', max_col='Max'):
    """Assigner un segment √† une valeur"""
    for _, segment in segments_df.iterrows():
        if segment[min_col] <= value <= segment[max_col]:
            return segment['Groupe']
    return segments_df.iloc[-1]['Groupe']  # Dernier segment par d√©faut

def prepare_data():
    """Pr√©parer toutes les donn√©es selon le cahier des charges"""
    elr_data, tarif_data, marche_data, taux_data = create_sample_data()
    
    # 1. Filtrage ELR pour "Atout PRO"
    elr_atouts_pro = elr_data[elr_data['Pol Formule'] == 'Atout PRO'].copy()
    
    # 2. Cr√©er des segments ELR (20 groupes)
    segment_elr = create_segments(elr_atouts_pro, 'Pourcentage ELR', 20, 'ELR')
    
    # 3. Filtrer Tarif Vendu pour "AtoutsPRO"
    tarif_atoutspro = tarif_data[tarif_data['Produit'] == 'AtoutsPRO'].copy()
    
    # 4. Fusion ELR + Tarif Vendu
    data_all = pd.merge(
        elr_atouts_pro,
        tarif_atoutspro,
        left_on='Code activit√©',
        right_on='Code_acti_ET100',
        how='inner'
    )
    
    # 5. Enrichissement avec march√©
    data_all = pd.merge(
        data_all,
        marche_data,
        left_on='Code activit√©',
        right_on='CodeActivite_AtoutsPro',
        how='left'
    )
    data_all.rename(columns={'march√©_r√©el': 'march√©'}, inplace=True)
    
    # 6. Fusion avec taux de concr√©tisation
    data_all_fusione = pd.merge(
        data_all,
        taux_data,
        left_on='Code activit√©',
        right_on='Code',
        how='left'
    )
    
    # 7. Cr√©er des segments de taux de concr√©tisation (10 groupes)
    segment_taux = create_segments(data_all_fusione, 'Taux_Concretisation', 10, 'TAUX')
    
    # 8. Assigner les segments aux donn√©es
    data_all_fusione['Segment_ELR'] = data_all_fusione['Pourcentage ELR'].apply(
        lambda x: assign_segment(x, segment_elr)
    )
    data_all_fusione['Segment_Taux'] = data_all_fusione['Taux_Concretisation'].apply(
        lambda x: assign_segment(x, segment_taux)
    )
    
    return data_all_fusione, segment_elr, segment_taux

def calculate_kpis(df):
    """Calculer les indicateurs cl√©s"""
    kpis = {
        'Total_AN24': df['Nombre_AN24'].sum(),
        'Taux_Concretisation_Global': df['Taux_Concretisation'].mean(),
        'Total_Tarif_Vendu': df['Somme_tarif_vendu'].sum(),
        'Total_Tarif_Vendu_SansFDR': df['Somme_tarif_vendu_SansFDR'].sum(),
        'Nb_Activites': df['Code activit√©'].nunique()
    }
    return kpis

def create_majoration_matrix(segment_elr, segment_taux, sigma, alpha_range, beta_range):
    """Cr√©er la matrice de majoration"""
    n_taux = len(segment_taux)  # 10
    n_elr = len(segment_elr)    # 20
    
    # Initialiser la matrice
    matrix = np.zeros((n_taux, n_elr))
    
    # Calculer les pas alpha et beta
    alpha_total = sigma * 0.6  # 60% de la variation pour les taux
    beta_total = sigma * 0.4   # 40% de la variation pour ELR
    
    # Distribution des pas (plus important pour les segments √† risque)
    alphas = np.linspace(alpha_total/n_taux * 0.5, alpha_total/n_taux * 1.5, n_taux-1)
    betas = np.linspace(beta_total/n_elr * 0.5, beta_total/n_elr * 1.5, n_elr-1)
    
    # Remplir la matrice
    matrix[0, 0] = sigma  # M_{1,1} = sigma
    
    # Remplir la premi√®re ligne
    for j in range(1, n_elr):
        matrix[0, j] = max(0.1, matrix[0, j-1] - betas[j-1])
    
    # Remplir la premi√®re colonne
    for i in range(1, n_taux):
        matrix[i, 0] = max(0.1, matrix[i-1, 0] - alphas[i-1])
    
    # Remplir le reste de la matrice
    for i in range(1, n_taux):
        for j in range(1, n_elr):
            matrix[i, j] = max(0.1, (matrix[i-1, j] + matrix[i, j-1]) / 2 - (alphas[i-1] + betas[j-1]) / 4)
    
    return matrix

# Interface utilisateur
def main():
    # Sidebar pour les param√®tres
    st.sidebar.header("‚öôÔ∏è Param√®tres")
    
    # Chargement des donn√©es
    with st.spinner("Chargement des donn√©es..."):
        data_all_fusione, segment_elr, segment_taux = prepare_data()
    
    # Onglets principaux
    tab1, tab2, tab3, tab4 = st.tabs([
        "üìà Analyse Globale", 
        "üîó Corr√©lations", 
        "üéØ Filtrage par Activit√©", 
        "üìã Matrice de Majoration"
    ])
    
    # TAB 1: Analyse Globale
    with tab1:
        st.header("üìä Vue d'ensemble des donn√©es")
        
        # KPIs
        kpis = calculate_kpis(data_all_fusione)
        
        col1, col2, col3, col4, col5 = st.columns(5)
        
        with col1:
            st.metric(
                "Total AN24",
                f"{kpis['Total_AN24']:,}",
                help="Nombre total d'affaires nouvelles"
            )
        
        with col2:
            st.metric(
                "Taux Concr√©tisation Global",
                f"{kpis['Taux_Concretisation_Global']:.1%}",
                help="Ratio entre affaires conclues et totales"
            )
        
        with col3:
            st.metric(
                "CA Total",
                f"‚Ç¨{kpis['Total_Tarif_Vendu']:,.0f}",
                help="Chiffre d'affaires total"
            )
        
        with col4:
            st.metric(
                "CA sans FDR",
                f"‚Ç¨{kpis['Total_Tarif_Vendu_SansFDR']:,.0f}",
                help="Chiffre d'affaires hors frais de dossier"
            )
        
        with col5:
            st.metric(
                "Nb Activit√©s",
                f"{kpis['Nb_Activites']}",
                help="Nombre d'activit√©s diff√©rentes"
            )
        
        st.markdown("---")
        
        # Graphiques
        col1, col2 = st.columns(2)
        
        with col1:
            # R√©partition par march√©
            marche_data = data_all_fusione.groupby('march√©').agg({
                'Nombre_AN24': 'sum',
                'Somme_tarif_vendu': 'sum'
            }).reset_index()
            
            fig_marche = px.pie(
                marche_data, 
                values='Nombre_AN24', 
                names='march√©',
                title="R√©partition des AN24 par March√©"
            )
            st.plotly_chart(fig_marche, use_container_width=True)
        
        with col2:
            # Top 10 activit√©s
            top_activites = data_all_fusione.nlargest(10, 'Nombre_AN24')[
                ['Code activit√©', 'Nombre_AN24', 'Libell√©']
            ]
            
            fig_top = px.bar(
                top_activites,
                x='Nombre_AN24',
                y='Code activit√©',
                orientation='h',
                title="Top 10 Activit√©s par AN24"
            )
            fig_top.update_layout(yaxis={'categoryorder': 'total ascending'})
            st.plotly_chart(fig_top, use_container_width=True)
        
        # Distribution des indicateurs
        col1, col2 = st.columns(2)
        
        with col1:
            fig_elr = px.histogram(
                data_all_fusione,
                x='Pourcentage ELR',
                nbins=30,
                title="Distribution des Pourcentages ELR"
            )
            st.plotly_chart(fig_elr, use_container_width=True)
        
        with col2:
            fig_taux = px.histogram(
                data_all_fusione,
                x='Taux_Concretisation',
                nbins=30,
                title="Distribution des Taux de Concr√©tisation"
            )
            st.plotly_chart(fig_taux, use_container_width=True)
        
        # Tableau des donn√©es
        st.subheader("üìã Donn√©es d√©taill√©es")
        st.dataframe(
            data_all_fusione[[
                'Code activit√©', 'Libell√©', 'march√©', 'Pourcentage ELR',
                'Taux_Concretisation', 'Nombre_AN24', 'Somme_tarif_vendu'
            ]].round(2),
            use_container_width=True
        )
    
    # TAB 2: Corr√©lations
    with tab2:
        st.header("üîó Analyse de Corr√©lation ELR vs Taux de Concr√©tisation")
        
        # Calcul de la corr√©lation
        corr_coef, p_value = pearsonr(
            data_all_fusione['Pourcentage ELR'],
            data_all_fusione['Taux_Concretisation']
        )
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Coefficient de Corr√©lation", f"{corr_coef:.3f}")
        with col2:
            st.metric("P-value", f"{p_value:.3f}")
        with col3:
            interpretation = "Forte" if abs(corr_coef) > 0.7 else "Mod√©r√©e" if abs(corr_coef) > 0.3 else "Faible"
            st.metric("Interpr√©tation", interpretation)
        
        # Scatter plot avec ligne de tendance
        fig_scatter = px.scatter(
            data_all_fusione,
            x='Pourcentage ELR',
            y='Taux_Concretisation',
            size='Nombre_AN24',
            color='march√©',
            trendline='ols',
            title=f"Corr√©lation ELR vs Taux de Concr√©tisation (r={corr_coef:.3f})",
            labels={
                'Pourcentage ELR': 'Pourcentage ELR (%)',
                'Taux_Concretisation': 'Taux de Concr√©tisation'
            }
        )
        st.plotly_chart(fig_scatter, use_container_width=True)
        
        # Heatmap de corr√©lation
        correlation_vars = [
            'Pourcentage ELR', 'Taux_Concretisation', 'Nombre_AN24',
            'Somme_tarif_vendu', 'moyenne_tarif_vendu_HT'
        ]
        
        corr_matrix = data_all_fusione[correlation_vars].corr()
        
        fig_heatmap = px.imshow(
            corr_matrix,
            text_auto=True,
            aspect="auto",
            title="Matrice de Corr√©lation",
            color_continuous_scale='RdBu_r'
        )
        st.plotly_chart(fig_heatmap, use_container_width=True)
    
    # TAB 3: Filtrage par Activit√©
    with tab3:
        st.header("üéØ Analyse par Code d'Activit√©")
        
        # S√©lecteur d'activit√©s
        selected_activities = st.multiselect(
            "S√©lectionner les codes d'activit√© √† analyser:",
            options=data_all_fusione['Code activit√©'].unique(),
            default=data_all_fusione['Code activit√©'].unique()[:5]
        )
        
        if selected_activities:
            filtered_data = data_all_fusione[
                data_all_fusione['Code activit√©'].isin(selected_activities)
            ]
            
            # KPIs filtr√©s
            filtered_kpis = calculate_kpis(filtered_data)
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total AN24 (filtr√©s)", f"{filtered_kpis['Total_AN24']:,}")
            with col2:
                st.metric("Taux Concr√©tisation Moyen", f"{filtered_kpis['Taux_Concretisation_Global']:.1%}")
            with col3:
                st.metric("CA Total (filtr√©s)", f"‚Ç¨{filtered_kpis['Total_Tarif_Vendu']:,.0f}")
            
            # Comparaison des activit√©s s√©lectionn√©es
            comparison_data = filtered_data.groupby('Code activit√©').agg({
                'Nombre_AN24': 'sum',
                'Pourcentage ELR': 'mean',
                'Taux_Concretisation': 'mean',
                'Somme_tarif_vendu': 'sum'
            }).reset_index()
            
            fig_comparison = make_subplots(
                rows=2, cols=2,
                subplot_titles=('AN24 par Activit√©', 'ELR Moyen', 'Taux de Concr√©tisation', 'CA par Activit√©'),
                specs=[[{"secondary_y": False}, {"secondary_y": False}],
                       [{"secondary_y": False}, {"secondary_y": False}]]
            )
            
            # AN24
            fig_comparison.add_trace(
                go.Bar(x=comparison_data['Code activit√©'], 
                      y=comparison_data['Nombre_AN24'], 
                      name='AN24'),
                row=1, col=1
            )
            
            # ELR
            fig_comparison.add_trace(
                go.Bar(x=comparison_data['Code activit√©'], 
                      y=comparison_data['Pourcentage ELR'], 
                      name='ELR %'),
                row=1, col=2
            )
            
            # Taux
            fig_comparison.add_trace(
                go.Bar(x=comparison_data['Code activit√©'], 
                      y=comparison_data['Taux_Concretisation'], 
                      name='Taux'),
                row=2, col=1
            )
            
            # CA
            fig_comparison.add_trace(
                go.Bar(x=comparison_data['Code activit√©'], 
                      y=comparison_data['Somme_tarif_vendu'], 
                      name='CA'),
                row=2, col=2
            )
            
            fig_comparison.update_layout(height=600, showlegend=False, title_text="Comparaison des Activit√©s S√©lectionn√©es")
            st.plotly_chart(fig_comparison, use_container_width=True)
            
            # Tableau d√©taill√©
            st.subheader("D√©tails des activit√©s s√©lectionn√©es")
            st.dataframe(comparison_data.round(2), use_container_width=True)
    
    # TAB 4: Matrice de Majoration
    with tab4:
        st.header("üìã Matrice de Majoration")
        
        # Param√®tres de la matrice
        col1, col2 = st.columns(2)
        
        with col1:
            sigma = st.slider(
                "Valeur maximale œÉ (M‚ÇÅ,‚ÇÅ)",
                min_value=1.0,
                max_value=5.0,
                value=2.5,
                step=0.1,
                help="Coefficient maximum de majoration"
            )
        
        with col2:
            st.write("**Param√®tres des segments:**")
            st.write(f"‚Ä¢ Segments ELR: {len(segment_elr)}")
            st.write(f"‚Ä¢ Segments Taux: {len(segment_taux)}")
            st.write(f"‚Ä¢ Taille matrice: {len(segment_taux)} √ó {len(segment_elr)}")
        
        # Calcul de la matrice
        alpha_range = (0.1, 0.3)
        beta_range = (0.05, 0.2)
        
        matrix = create_majoration_matrix(segment_elr, segment_taux, sigma, alpha_range, beta_range)
        
        # Visualisation de la matrice
        col1, col2 = st.columns([2, 1])
        
        with col1:
            # Heatmap de la matrice
            fig_matrix = px.imshow(
                matrix,
                labels=dict(x="Segments ELR", y="Segments Taux", color="Coefficient"),
                x=[f"ELR_{i+1:02d}" for i in range(len(segment_elr))],
                y=[f"TAUX_{i+1:02d}" for i in range(len(segment_taux))],
                color_continuous_scale='RdYlBu_r',
                title="Matrice de Majoration"
            )
            fig_matrix.update_layout(height=600)
            st.plotly_chart(fig_matrix, use_container_width=True)
        
        with col2:
            st.subheader("Statistiques de la matrice")
            st.metric("Coefficient minimum", f"{matrix.min():.3f}")
            st.metric("Coefficient maximum", f"{matrix.max():.3f}")
            st.metric("Coefficient moyen", f"{matrix.mean():.3f}")
            st.metric("√âcart-type", f"{matrix.std():.3f}")
            
            # Affichage des segments critiques
            st.subheader("Zones critiques")
            max_pos = np.unravel_index(matrix.argmax(), matrix.shape)
            min_pos = np.unravel_index(matrix.argmin(), matrix.shape)
            
            st.write(f"**Maximum:** TAUX_{max_pos[0]+1:02d} √ó ELR_{max_pos[1]+1:02d}")
            st.write(f"Coefficient: {matrix[max_pos]:.3f}")
            
            st.write(f"**Minimum:** TAUX_{min_pos[0]+1:02d} √ó ELR_{min_pos[1]+1:02d}")
            st.write(f"Coefficient: {matrix[min_pos]:.3f}")
        
        # Tableau de la matrice
        st.subheader("Matrice d√©taill√©e")
        
        matrix_df = pd.DataFrame(
            matrix,
            columns=[f"ELR_{i+1:02d}" for i in range(len(segment_elr))],
            index=[f"TAUX_{i+1:02d}" for i in range(len(segment_taux))]
        )
        
        st.dataframe(matrix_df.round(3), use_container_width=True)
        
        # Export de la matrice
        if st.button("üì• T√©l√©charger la matrice"):
            csv = matrix_df.to_csv()
            st.download_button(
                label="T√©l√©charger CSV",
                data=csv,
                file_name=f"matrice_majoration_sigma_{sigma}.csv",
                mime="text/csv"
            )

if __name__ == "__main__":
    main()
