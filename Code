import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict
import random
from dataclasses import dataclass
from enum import Enum

class SegmentType(Enum):
    A = "A"  # Haute conversion, Haute rentabilité - Protéger
    B = "B"  # Haute conversion, Faible rentabilité - Majorer fort
    C = "C"  # Faible conversion, Haute rentabilité - Modéré
    D = "D"  # Faible conversion, Faible rentabilité - Décourager

@dataclass
class Individual:
    """Individu dans la population NSGA-II"""
    majoration_rates: np.ndarray  # Matrice 10x20 des taux de majoration
    objectives: Tuple[float, float] = None  # (profit, conversion_rate)
    rank: int = 0
    crowding_distance: float = 0.0
    
    def _post_init_(self):
        self.majoration_rates = self.majoration_rates.reshape(10, 20)

class InsuranceOptimizer:
    """
    Optimiseur NSGA-II pour les taux de majoration d'assurance
    Basé sur: Deb, K. et al. (2002) "A fast and elitist multiobjective genetic algorithm: NSGA-II"
    IEEE Transactions on Evolutionary Computation, 6(2), 182-197
    """
    
    def _init_(self, conversion_segments: int = 10, profitability_segments: int = 20):
        self.n_conv = conversion_segments
        self.n_profit = profitability_segments
        self.total_segments = conversion_segments * profitability_segments
        
        # Paramètres du problème
        self.setup_problem_parameters()
        
        # Paramètres NSGA-II
        self.population_size = 100
        self.max_generations = 500
        self.crossover_prob = 0.8
        self.mutation_prob = 1.0 / self.total_segments  # Formule: 1/n_variables
        self.eta_c = 15  # Paramètre de croisement SBX
        self.eta_m = 20  # Paramètre de mutation polynomiale
        
    def setup_problem_parameters(self):
        """Initialise les paramètres du problème d'assurance"""
        
        # Taux de conversion par segment (10 segments)
        self.C0 = np.array([0.20, 0.35, 0.45, 0.55, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90])
        
        # Taux de rentabilité par segment (20 segments)
        self.R0 = np.linspace(0.02, 0.20, 20)
        
        # Volumes par segment (matrice 10x20)
        np.random.seed(42)
        self.volumes = np.random.uniform(1000, 10000, (self.n_conv, self.n_profit))
        
        # Élasticité prix (matrice 10x20)
        self.elasticity = np.random.uniform(0.5, 2.0, (self.n_conv, self.n_profit))
        
        # Seuils de classification
        self.theta_C = np.percentile(self.C0, 70)  # 0.70
        self.theta_R = np.percentile(self.R0, 70)  # 0.14
        
        # Classification des segments
        self.segment_types = self.classify_segments()
        
        # Coefficients de bonus/pénalité
        self.lambda_A = 10.0  # Pénalise majoration élevée
        self.lambda_B = 5.0   # Encourage majoration
        self.lambda_C = 3.0   # Encourage protection
        self.lambda_D = 8.0   # Encourage forte majoration
        
    def classify_segments(self) -> np.ndarray:
        """Classification des 200 segments selon les formules définies"""
        segments = np.empty((self.n_conv, self.n_profit), dtype=object)
        
        for j in range(self.n_conv):
            for k in range(self.n_profit):
                if self.C0[j] >= self.theta_C and self.R0[k] >= self.theta_R:
                    segments[j, k] = SegmentType.A
                elif self.C0[j] >= self.theta_C and self.R0[k] < self.theta_R:
                    segments[j, k] = SegmentType.B
                elif self.C0[j] < self.theta_C and self.R0[k] >= self.theta_R:
                    segments[j, k] = SegmentType.C
                else:
                    segments[j, k] = SegmentType.D
        
        return segments
    
    def conversion_function(self, m_jk: float, j: int, k: int) -> float:
        """
        Fonction de conversion avec élasticité: C_{j,k}(m_{j,k}) = C_{j,0} * (1 + m_{j,k})^{-ε_{j,k}}
        """
        return self.C0[j] * np.power(1 + m_jk, -self.elasticity[j, k])
    
    def adjusted_profitability(self, m_jk: float, j: int, k: int) -> float:
        """
        Rentabilité ajustée: R_{j,k}(m_{j,k}) = R_{0,k} + α_{j,k} * m_{j,k} + β_{j,k}(m_{j,k})
        """
        base_profitability = self.R0[k]
        alpha = 0.1  # Coefficient linéaire
        
        # Bonus/Pénalité selon le type de segment
        segment_type = self.segment_types[j, k]
        
        if segment_type == SegmentType.A:
            beta = -self.lambda_A * m_jk**2  # Pénalise majoration élevée
        elif segment_type == SegmentType.B:
            beta = self.lambda_B * m_jk      # Encourage majoration
        elif segment_type == SegmentType.C:
            beta = -self.lambda_C * m_jk     # Encourage protection
        else:  # SegmentType.D
            beta = self.lambda_D * m_jk**2   # Encourage forte majoration
        
        return base_profitability + alpha * m_jk + beta
    
    def get_bounds(self, j: int, k: int) -> Tuple[float, float]:
        """Contraintes de bornes selon le type de segment"""
        segment_type = self.segment_types[j, k]
        
        bounds = {
            SegmentType.A: (0.0, 0.05),    # Protéger
            SegmentType.B: (0.12, 0.30),   # Majorer fort
            SegmentType.C: (0.03, 0.12),   # Modéré
            SegmentType.D: (0.20, 0.40)    # Décourager
        }
        
        return bounds[segment_type]
    
    def evaluate_objectives(self, individual: Individual) -> Tuple[float, float]:
        """
        Évalue les deux objectifs:
        f1 = Profit total
        f2 = Taux de conversion global
        """
        m_matrix = individual.majoration_rates
        total_profit = 0.0
        total_weighted_conversion = 0.0
        total_volume = 0.0
        
        for j in range(self.n_conv):
            for k in range(self.n_profit):
                m_jk = m_matrix[j, k]
                
                # Calculs selon les formules
                conversion = self.conversion_function(m_jk, j, k)
                profitability = self.adjusted_profitability(m_jk, j, k)
                volume = self.volumes[j, k]
                
                # Contribution au profit total
                segment_profit = volume * conversion * profitability * (1 + m_jk)
                total_profit += segment_profit
                
                # Contribution à la conversion globale
                total_weighted_conversion += volume * conversion
                total_volume += volume
        
        # Objectifs à maximiser
        f1 = total_profit  # Profit total
        f2 = total_weighted_conversion / total_volume  # Conversion globale
        
        return f1, f2
    
    def initialize_population(self) -> List[Individual]:
        """Initialise la population avec des contraintes de bornes"""
        population = []
        
        for _ in range(self.population_size):
            majoration_rates = np.zeros((self.n_conv, self.n_profit))
            
            for j in range(self.n_conv):
                for k in range(self.n_profit):
                    min_bound, max_bound = self.get_bounds(j, k)
                    majoration_rates[j, k] = np.random.uniform(min_bound, max_bound)
            
            individual = Individual(majoration_rates.flatten())
            individual.objectives = self.evaluate_objectives(individual)
            population.append(individual)
        
        return population
    
    def dominates(self, ind1: Individual, ind2: Individual) -> bool:
        """Test de dominance de Pareto"""
        f1_1, f2_1 = ind1.objectives
        f1_2, f2_2 = ind2.objectives
        
        # Pour maximisation des deux objectifs
        return (f1_1 >= f1_2 and f2_1 >= f2_2) and (f1_1 > f1_2 or f2_1 > f2_2)
    
    def fast_non_dominated_sort(self, population: List[Individual]) -> List[List[Individual]]:
        """
        Tri rapide non-dominé O(MN²)
        Algorithme de Deb et al. (2002)
        """
        fronts = [[]]
        
        for p in population:
            p.domination_count = 0
            p.dominated_solutions = []
            
            for q in population:
                if self.dominates(p, q):
                    p.dominated_solutions.append(q)
                elif self.dominates(q, p):
                    p.domination_count += 1
            
            if p.domination_count == 0:
                p.rank = 0
                fronts[0].append(p)
        
        i = 0
        while len(fronts[i]) > 0:
            next_front = []
            for p in fronts[i]:
                for q in p.dominated_solutions:
                    q.domination_count -= 1
                    if q.domination_count == 0:
                        q.rank = i + 1
                        next_front.append(q)
            i += 1
            fronts.append(next_front)
        
        return fronts[:-1]  # Enlever le dernier front vide
    
    def calculate_crowding_distance(self, front: List[Individual]):
        """
        Calcul de la distance de crowding
        Algorithme de Deb et al. (2002)
        """
        if len(front) <= 2:
            for individual in front:
                individual.crowding_distance = float('inf')
            return
        
        # Initialiser toutes les distances à 0
        for individual in front:
            individual.crowding_distance = 0.0
        
        # Pour chaque objectif
        for obj_idx in range(2):  # 2 objectifs
            # Trier par objectif
            front.sort(key=lambda x: x.objectives[obj_idx], reverse=True)
            
            # Points extrêmes ont une distance infinie
            front[0].crowding_distance = float('inf')
            front[-1].crowding_distance = float('inf')
            
            # Normalisation
            obj_range = front[0].objectives[obj_idx] - front[-1].objectives[obj_idx]
            if obj_range == 0:
                continue
            
            # Calculer les distances
            for i in range(1, len(front) - 1):
                distance = (front[i-1].objectives[obj_idx] - front[i+1].objectives[obj_idx]) / obj_range
                front[i].crowding_distance += distance
    
    def tournament_selection(self, population: List[Individual]) -> Individual:
        """Sélection par tournoi avec rang et distance de crowding"""
        candidate1 = random.choice(population)
        candidate2 = random.choice(population)
        
        # Comparer selon NSGA-II
        if candidate1.rank < candidate2.rank:
            return candidate1
        elif candidate1.rank > candidate2.rank:
            return candidate2
        else:
            # Même rang, utiliser la distance de crowding
            return candidate1 if candidate1.crowding_distance > candidate2.crowding_distance else candidate2
    
    def sbx_crossover(self, parent1: Individual, parent2: Individual) -> Tuple[Individual, Individual]:
        """Croisement SBX (Simulated Binary Crossover)"""
        if random.random() > self.crossover_prob:
            return parent1, parent2
        
        child1_genes = np.copy(parent1.majoration_rates.flatten())
        child2_genes = np.copy(parent2.majoration_rates.flatten())
        
        for i in range(len(child1_genes)):
            if random.random() <= 0.5:
                j = i // self.n_profit
                k = i % self.n_profit
                
                min_bound, max_bound = self.get_bounds(j, k)
                
                y1, y2 = child1_genes[i], child2_genes[i]
                
                if abs(y1 - y2) > 1e-14:
                    if y1 > y2:
                        y1, y2 = y2, y1
                    
                    beta = 1.0 + 2.0 * (y1 - min_bound) / (y2 - y1)
                    alpha = 2.0 - beta ** -(self.eta_c + 1.0)
                    
                    if random.random() <= 1.0 / alpha:
                        betaq = (random.random() * alpha) ** (1.0 / (self.eta_c + 1.0))
                    else:
                        betaq = (1.0 / (2.0 - random.random() * alpha)) ** (1.0 / (self.eta_c + 1.0))
                    
                    c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1))
                    
                    beta = 1.0 + 2.0 * (max_bound - y2) / (y2 - y1)
                    alpha = 2.0 - beta ** -(self.eta_c + 1.0)
                    
                    if random.random() <= 1.0 / alpha:
                        betaq = (random.random() * alpha) ** (1.0 / (self.eta_c + 1.0))
                    else:
                        betaq = (1.0 / (2.0 - random.random() * alpha)) ** (1.0 / (self.eta_c + 1.0))
                    
                    c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1))
                    
                    c1 = np.clip(c1, min_bound, max_bound)
                    c2 = np.clip(c2, min_bound, max_bound)
                    
                    if random.random() <= 0.5:
                        child1_genes[i] = c2
                        child2_genes[i] = c1
                    else:
                        child1_genes[i] = c1
                        child2_genes[i] = c2
        
        child1 = Individual(child1_genes)
        child2 = Individual(child2_genes)
        
        return child1, child2
    
    def polynomial_mutation(self, individual: Individual) -> Individual:
        """Mutation polynomiale"""
        mutated_genes = np.copy(individual.majoration_rates.flatten())
        
        for i in range(len(mutated_genes)):
            if random.random() <= self.mutation_prob:
                j = i // self.n_profit
                k = i % self.n_profit
                
                min_bound, max_bound = self.get_bounds(j, k)
                
                y = mutated_genes[i]
                delta1 = (y - min_bound) / (max_bound - min_bound)
                delta2 = (max_bound - y) / (max_bound - min_bound)
                
                rnd = random.random()
                mut_pow = 1.0 / (self.eta_m + 1.0)
                
                if rnd <= 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (xy ** (self.eta_m + 1.0))
                    deltaq = val ** mut_pow - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (xy ** (self.eta_m + 1.0))
                    deltaq = 1.0 - val ** mut_pow
                
                y = y + deltaq * (max_bound - min_bound)
                y = np.clip(y, min_bound, max_bound)
                mutated_genes[i] = y
        
        return Individual(mutated_genes)
    
    def optimize(self) -> Tuple[List[Individual], Dict]:
        """
        Algorithme NSGA-II principal
        Retourne le front de Pareto et les statistiques
        """
        # Initialisation
        population = self.initialize_population()
        
        # Statistiques
        stats = {
            'best_profit': [],
            'best_conversion': [],
            'average_profit': [],
            'average_conversion': []
        }
        
        for generation in range(self.max_generations):
            # Créer la descendance
            offspring = []
            
            while len(offspring) < self.population_size:
                parent1 = self.tournament_selection(population)
                parent2 = self.tournament_selection(population)
                
                child1, child2 = self.sbx_crossover(parent1, parent2)
                child1 = self.polynomial_mutation(child1)
                child2 = self.polynomial_mutation(child2)
                
                child1.objectives = self.evaluate_objectives(child1)
                child2.objectives = self.evaluate_objectives(child2)
                
                offspring.extend([child1, child2])
            
            offspring = offspring[:self.population_size]
            
            # Combiner population et descendance
            combined_population = population + offspring
            
            # Tri non-dominé rapide
            fronts = self.fast_non_dominated_sort(combined_population)
            
            # Nouvelle population
            new_population = []
            front_idx = 0
            
            while len(new_population) + len(fronts[front_idx]) <= self.population_size:
                self.calculate_crowding_distance(fronts[front_idx])
                new_population.extend(fronts[front_idx])
                front_idx += 1
            
            # Compléter avec le front suivant si nécessaire
            if len(new_population) < self.population_size:
                self.calculate_crowding_distance(fronts[front_idx])
                fronts[front_idx].sort(key=lambda x: x.crowding_distance, reverse=True)
                remaining = self.population_size - len(new_population)
                new_population.extend(fronts[front_idx][:remaining])
            
            population = new_population
            
            # Statistiques
            profits = [ind.objectives[0] for ind in population]
            conversions = [ind.objectives[1] for ind in population]
            
            stats['best_profit'].append(max(profits))
            stats['best_conversion'].append(max(conversions))
            stats['average_profit'].append(np.mean(profits))
            stats['average_conversion'].append(np.mean(conversions))
            
            if generation % 50 == 0:
                print(f"Génération {generation}: Meilleur profit = {max(profits):.2f}, Meilleure conversion = {max(conversions):.4f}")
        
        # Retourner le front de Pareto (premier front)
        final_fronts = self.fast_non_dominated_sort(population)
        pareto_front = final_fronts[0]
        
        return pareto_front, stats
    
    def analyze_results(self, pareto_front: List[Individual]):
        """Analyse des résultats d'optimisation"""
        print(f"\n=== ANALYSE DES RÉSULTATS ===")
        print(f"Taille du front de Pareto: {len(pareto_front)}")
        
        # Statistiques du front de Pareto
        profits = [ind.objectives[0] for ind in pareto_front]
        conversions = [ind.objectives[1] for ind in pareto_front]
        
        print(f"\nProfit:")
        print(f"  Min: {min(profits):.2f}")
        print(f"  Max: {max(profits):.2f}")
        print(f"  Moyenne: {np.mean(profits):.2f}")
        
        print(f"\nTaux de conversion:")
        print(f"  Min: {min(conversions):.4f}")
        print(f"  Max: {max(conversions):.4f}")
        print(f"  Moyenne: {np.mean(conversions):.4f}")
        
        # Analyser les taux de majoration par type de segment
        best_solution = max(pareto_front, key=lambda x: x.objectives[0])  # Meilleur profit
        
        print(f"\n=== SOLUTION OPTIMALE (Meilleur profit) ===")
        
        segment_stats = {seg_type: [] for seg_type in SegmentType}
        
        for j in range(self.n_conv):
            for k in range(self.n_profit):
                seg_type = self.segment_types[j, k]
                majoration = best_solution.majoration_rates[j, k]
                segment_stats[seg_type].append(majoration)
        
        for seg_type, majorations in segment_stats.items():
            if majorations:
                print(f"\nSegment {seg_type.value}:")
                print(f"  Nombre: {len(majorations)}")
                print(f"  Majoration moyenne: {np.mean(majorations):.3f}")
                print(f"  Majoration min-max: [{min(majorations):.3f}, {max(majorations):.3f}]")
        
        return best_solution

# Exemple d'utilisation
if _name_ == "_main_":
    print("=== OPTIMISATION NSGA-II DES TAUX DE MAJORATION D'ASSURANCE ===")
    print("Basé sur: Deb, K. et al. (2002) NSGA-II: IEEE Trans. Evolutionary Computation")
    
    # Créer l'optimiseur
    optimizer = InsuranceOptimizer()
    
    # Afficher la classification des segments
    print(f"\nClassification des segments (seuils: Conv≥{optimizer.theta_C:.2f}, Rent≥{optimizer.theta_R:.3f}):")
    type_counts = {}
    for j in range(10):
        for k in range(20):
            seg_type = optimizer.segment_types[j, k]
            type_counts[seg_type.value] = type_counts.get(seg_type.value, 0) + 1
    
    for seg_type, count in type_counts.items():
        print(f"  Segment {seg_type}: {count} combinaisons")
    
    # Lancer l'optimisation
    print("\nDémarrage de l'optimisation NSGA-II...")
    pareto_front, stats = optimizer.optimize()
    
    # Analyser les résultats
    best_solution = optimizer.analyze_results(pareto_front)
    
    # Visualisation
    plt.figure(figsize=(15, 5))
    
    # Front de Pareto
    plt.subplot(1, 3, 1)
    profits = [ind.objectives[0] for ind in pareto_front]
    conversions = [ind.objectives[1] for ind in pareto_front]
    plt.scatter(profits, conversions, c='red', alpha=0.7)
    plt.xlabel('Profit Total')
    plt.ylabel('Taux de Conversion Global')
    plt.title('Front de Pareto')
    plt.grid(True)
    
    # Évolution du profit
    plt.subplot(1, 3, 2)
    plt.plot(stats['best_profit'], label='Meilleur', color='red')
    plt.plot(stats['average_profit'], label='Moyen', color='blue')
    plt.xlabel('Génération')
    plt.ylabel('Profit')
    plt.title('Évolution du Profit')
    plt.legend()
    plt.grid(True)
    
    # Évolution de la conversion
    plt.subplot(1, 3, 3)
    plt.plot(stats['best_conversion'], label='Meilleure', color='red')
    plt.plot(stats['average_conversion'], label='Moyenne', color='blue')
    plt.xlabel('Génération')
    plt.ylabel('Taux de Conversion')
    plt.title('Évolution de la Conversion')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n=== MATRICE DES TAUX DE MAJORATION OPTIMAUX ===")
    print("Lignes = Segments de conversion, Colonnes = Segments de rentabilité")
    print(f"Matrice {optimizer.n_conv}x{optimizer.n_profit}:")
    print(np.round(best_solution.majoration_rates, 3))
