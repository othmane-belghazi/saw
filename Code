import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

###############################
# 1. Utilitaires de segmentation
###############################

def segment_indices(series: pd.Series, bins: int, method: str = "quantile") -> pd.Series:
    """Retourne un indice 1..bins pour chaque observation."""
    if method == "quantile":
        return pd.qcut(series, bins, labels=False, duplicates="drop") + 1
    elif method == "equal-width":
        return pd.cut(series, bins, labels=False, include_lowest=True) + 1
    else:
        raise ValueError("M√©thode de segmentation inconnue")

###############################
# 2. Calcul de la matrice dynamique
###############################

def calc_dynamic_matrix(
    df: pd.DataFrame,
    n_elr: int,
    n_conv: int,
    alpha: float,
    beta: float,
    coeff_max: float,
    k_cred: float,
    seg_method: str = "quantile",
):
    """Construit la matrice de coefficients selon la rampe dynamique.

    Retourne la matrice finale, la matrice avant cr√©dibilit√©,
    la matrice Z (poids) et la matrice d'effectifs N.
    """
    # Segmentation
    df = df.copy()
    df["elr_seg"] = segment_indices(df["ELR"], n_elr, seg_method)
    df["conv_seg"] = segment_indices(df["conversion"], n_conv, seg_method)

    # Effectifs par case
    N = (
        df.groupby(["elr_seg", "conv_seg"]).size().unstack(fill_value=0).astype(int)
    )

    # Rang 1..n
    i_idx = np.arange(1, n_elr + 1)[:, None]
    j_idx = np.arange(1, n_conv + 1)[None, :]

    # Score rampe
    score = (i_idx / n_elr) ** alpha * (j_idx / n_conv) ** beta

    # Matrice brute born√©e
    F = 1 + (coeff_max - 1) * score

    # Neutralisation 1
    K = (F * N.values).sum() / N.values.sum()
    M = F / K

    # Cr√©dibilit√©
    Z = N / (N + k_cred)
    M_cred = 1 + Z.values * (M - 1)

    # Neutralisation 2
    K2 = (M_cred * N.values).sum() / N.values.sum()
    M_final = M_cred / K2

    # Convert to DataFrame for display
    M_df = pd.DataFrame(M_final, index=N.index, columns=N.columns)
    M_pre_df = pd.DataFrame(M, index=N.index, columns=N.columns)
    Z_df = Z.astype(float)

    return M_df, M_pre_df, Z_df, N

###############################
# 3. Application Streamlit
###############################

def main():
    st.set_page_config(page_title="Matrice dynamique ELR √ó Concr√©tisation", layout="wide")
    st.title("üìà Matrice de majoration dynamique (ELR √ó Concr√©tisation)")

    with st.sidebar:
        st.header("Param√®tres")
        uploaded = st.file_uploader("üìÇ Charger un CSV (colonnes: premium, loss, conversion)")
        n_rows = st.slider("Taille √©chantillon (si donn√©es simul√©es)", 1000, 50000, 10000, 1000)
        n_elr = st.number_input("Nombre de segments ELR", 5, 40, 20, 1)
        n_conv = st.number_input("Nombre de segments Concr√©tisation", 5, 20, 10, 1)
        seg_method = st.selectbox("M√©thode de d√©coupe", ["quantile", "equal-width"])
        coeff_max = st.slider("Coefficient maximum (case extr√™me)", 1.05, 2.0, 1.30, 0.01)
        alpha = st.slider("Poids risque (Œ±)", 0.1, 2.0, 0.8, 0.05)
        beta = st.slider("Poids concr√©tisation (Œ≤)", 0.1, 2.0, 0.6, 0.05)
        k_cred = st.number_input("K cr√©dibilit√©", 0.0, 10000.0, 2000.0, 100.0)

    # Data ingestion ou simulation
    if uploaded is not None:
        df = pd.read_csv(uploaded)
        if "ELR" not in df.columns:
            df["ELR"] = df["loss"] / df["premium"].replace(0, np.nan)
        if "conversion" not in df.columns:
            st.error("La colonne 'conversion' est manquante dans le fichier")
            st.stop()
    else:
        st.info("Donn√©es simul√©es g√©n√©r√©es al√©atoirement")
        rng = np.random.default_rng(42)
        premium = rng.uniform(100, 500, size=n_rows)
        loss_ratio = rng.beta(2, 5, size=n_rows)
        loss = premium * loss_ratio
        conversion = rng.beta(3, 2, size=n_rows)  # moyenne env 0.60
        df = pd.DataFrame({"premium": premium, "loss": loss, "ELR": loss_ratio, "conversion": conversion})

    # Calcul de la matrice
    M_final, M_pre, Z, N = calc_dynamic_matrix(
        df, n_elr, n_conv, alpha, beta, coeff_max, k_cred, seg_method
    )

    #########################
    # Visualisations
    #########################
    col_main, col_side = st.columns([3, 1])
    with col_main:
        st.subheader("Coefficient final (apr√®s cr√©dibilit√©)")
        fig, ax = plt.subplots(figsize=(10, 6))
        sns.heatmap(M_final, cmap="coolwarm", center=1, linewidths=0.3, ax=ax)
        ax.set_xlabel("Segment Concr√©tisation j")
        ax.set_ylabel("Segment ELR i")
        st.pyplot(fig)

        st.markdown("*Distribution des coefficients*")
        fig2, ax2 = plt.subplots()
        ax2.hist(M_final.values.flatten(), bins=30)
        ax2.set_xlabel("Coefficient")
        ax2.set_ylabel("Effectif cases")
        st.pyplot(fig2)

    with col_side:
        st.subheader("R√©sum√© pond√©r√©")
        avg_coeff = (M_final.values * N.values).sum() / N.values.sum()
        st.metric("Moyenne pond√©r√©e", f"{avg_coeff:.4f}")
        st.metric("Coeff. max r√©el", f"{M_final.max().max():.3f}")
        st.metric("Coeff. min r√©el", f"{M_final.min().min():.3f}")

    #########################
    # T√©l√©chargements
    #########################
    csv_coeff = M_final.to_csv().encode("utf-8")
    st.download_button("üì• T√©l√©charger la matrice", csv_coeff, "coefficients.csv", "text/csv")

    if st.checkbox("Afficher matrices interm√©diaires"):
        st.write("Matrice avant cr√©dibilit√©")
        st.dataframe(M_pre.style.format("{:.3f}"))
        st.write("Poids de cr√©dibilit√© Z")
        st.dataframe(Z.style.format("{:.2f}"))
        st.write("Effectifs N")
        st.dataframe(N)

if _name_ == "_main_":
    main()
