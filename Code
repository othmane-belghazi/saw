import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

##############################
#      UTILITAIRES G√âN√âRAUX  #
##############################

def segment(series: pd.Series, n: int, method: str = "quantile") -> pd.Series:
    """Retourne le num√©ro de segment 0..n-1 pour chaque valeur de la s√©rie."""
    if method == "quantile":
        return pd.qcut(series, n, labels=False, duplicates="drop")
    elif method == "equal-width":
        return pd.cut(series, n, labels=False, include_lowest=True)
    else:
        raise ValueError("M√©thode inconnue : 'quantile' ou 'equal-width'.")


def build_matrix(
    df: pd.DataFrame,
    n_elr: int,
    n_conv: int,
    method: str,
    alpha: float,
    beta: float,
    smooth: bool,
    n_full: int,
):
    """Construit la matrice de majoration.

    Param√®tres
    ----------
    df : DataFrame contenant les colonnes premium, loss, conversion (0-1)
    n_elr, n_conv : nombre de segments
    method : 'quantile' ou 'equal-width'
    alpha, beta : pond√©rations (exposants) ELR vs Conversion
    smooth : active la cr√©dibilit√© limited-fluctuation
    n_full : effectif de pleine cr√©dibilit√©

    Retourne (M, N, R, C) o√π :
    * M : DataFrame matrice major√©e et renormalis√©e (moyenne pond√©r√©e = 1)
    * N : DataFrame effectifs
    * R : DataFrame (n_elr,1) ‚Äì facteurs ELR
    * C : DataFrame (1,n_conv) ‚Äì facteurs Concr√©tisation
    """
    df = df.copy()

    # Segmentation
    df["elr_seg"] = segment(df["ELR"], n_elr, method)
    df["conv_seg"] = segment(df["conversion"], n_conv, method)

    # Effectifs
    N = df.pivot_table(
        index="elr_seg", columns="conv_seg", values="premium", aggfunc="count", fill_value=0
    ).astype(int)

    # ELR moyens par segment + portefeuille
    ELR_i = df.groupby("elr_seg").apply(lambda d: d["loss"].sum() / d["premium"].sum())
    ELR_port = df["loss"].sum() / df["premium"].sum()
    R = (ELR_i / ELR_port).values

    # Concr√©tisation moyenne par segment + portefeuille
    Conv_j = df.groupby("conv_seg")["conversion"].mean()
    Conv_port = df["conversion"].mean()
    C = (Conv_j / Conv_port).values

    # Matrice brute
    m_brut = np.power.outer(R, np.ones_like(C)) ** alpha * np.power.outer(np.ones_like(R), C) ** beta

    # Normalisation neutre
    K_norm = (m_brut * N.values).sum() / N.values.sum()
    M = m_brut / K_norm

    # Cr√©dibilit√© Limited-Fluctuation
    if smooth:
        Z = np.minimum(1.0, np.sqrt(N.values / n_full))
        M = 1 + Z * (M - 1)
        # re-normalise
        K_norm2 = (M * N.values).sum() / N.values.sum()
        M /= K_norm2

    # Conversion en DataFrame
    M_df = pd.DataFrame(M, index=N.index, columns=N.columns)
    R_df = pd.DataFrame(R, index=N.index, columns=["R_i"])
    C_df = pd.DataFrame(C, index=["C_j"], columns=N.columns)

    return M_df, N, R_df, C_df

##############################
#         APP STREAMLIT      #
##############################

def main():
    st.set_page_config(page_title="Matrice Majoration ‚Äì Cas pratique", layout="wide")
    st.title("üß© Cas pratique : Matrice de majoration avec donn√©es simul√©es ou r√©elles")

    ########## BARRE LAT√âRALE ##########
    with st.sidebar:
        st.header("Choix des donn√©es")
        mode_data = st.radio("Source", ["G√©n√©ration al√©atoire", "Importer CSV"], index=0)
        if mode_data == "Importer CSV":
            uploaded = st.file_uploader("Donn√©es CSV")
        else:
            uploaded = None
            n_sim = st.number_input("Nb expositions simul√©es", 1_000, 100_000, 15_000, 1_000)
            seed = st.number_input("Seed RNG", 0, 1_000_000, 2025, 1)
            st.markdown("---")
            st.markdown("### Param√®tres simulation")
            prem_min, prem_max = st.slider("Premium min / max", 50, 1000, (150, 600))
            a_lr, b_lr = st.slider("Beta(Œ±, Œ≤) pour ELR", 0.5, 10.0, (2.5, 5.0), 0.1)
            a_cv, b_cv = st.slider("Beta(Œ±, Œ≤) pour Concr√©tisation", 0.5, 10.0, (2.0, 2.0), 0.1)
            st.caption("‚ûú Cliquer sur un autre champ pour r√©g√©n√©rer")
        st.markdown("---")
        st.header("Param√®tres matrice")
        n_elr = st.slider("Nb segments ELR", 5, 40, 20)
        n_conv = st.slider("Nb segments Concr√©tisation", 5, 20, 10)
        method = st.selectbox("D√©coupage", ["quantile", "equal-width"])
        alpha = st.slider("Poids ELR (Œ±)", 0.0, 2.0, 1.0, 0.05)
        beta = st.slider("Poids Concr√©tisation (Œ≤)", 0.0, 2.0, 1.0, 0.05)
        smooth = st.checkbox("Cr√©dibiliser (Limited-Fluctuation)", True)
        n_full = st.number_input("Effectif pleine cr√©dibilit√© N_F", 50, 10_000, 1_000, 50)

    ########## G√âN√âRATION / IMPORT ##########
    if uploaded is not None:
        df = pd.read_csv(uploaded)
    else:
        rng = np.random.default_rng(int(seed))
        premium = rng.uniform(prem_min, prem_max, int(n_sim))
        loss_ratio = rng.beta(a_lr, b_lr, int(n_sim))
        loss = premium * loss_ratio
        conversion = rng.beta(a_cv, b_cv, int(n_sim))
        df = pd.DataFrame({"premium": premium, "loss": loss, "conversion": conversion})

    # ELR coh√©rent
    df["ELR"] = df["loss"] / df["premium"].replace(0, np.nan)

    ########## CONSTRUCTION MATRICE ##########
    M, N, R_df, C_df = build_matrix(df, n_elr, n_conv, method, alpha, beta, smooth, n_full)

    ########## AFFICHAGE ##########
    st.subheader("Aper√ßu des premi√®res lignes du jeu de donn√©es")
    st.dataframe(df.head())

    col_heat, col_side = st.columns((4, 1))
    with col_heat:
        st.subheader("Matrice de majoration normalis√©e")
        fig, ax = plt.subplots(figsize=(9, 6))
        sns.heatmap(M, cmap="RdYlGn", center=1, linewidths=0.3, ax=ax)
        ax.set_xlabel("Segment Concr√©tisation j")
        ax.set_ylabel("Segment ELR i")
        st.pyplot(fig)
    with col_side:
        st.metric("Moyenne pond√©r√©e", f"{(M.values*N.values).sum()/N.values.sum():.4f}")
        st.write("### Facteurs R_i (ELR)")
        st.dataframe(R_df.style.format("{:.3f}"), height=300)
        st.write("### Facteurs C_j (Concr√©tisation)")
        st.dataframe(C_df.style.format("{:.3f}"))

    ########## T√âL√âCHARGEMENTS ##########
    st.markdown("---")
    csv_M = M.to_csv().encode("utf-8")
    st.download_button("üì• T√©l√©charger matrice (CSV)", csv_M, "matrix_majoration.csv", "text/csv")
    csv_N = N.to_csv().encode("utf-8")
    st.download_button("üì• T√©l√©charger effectifs (CSV)", csv_N, "effectifs.csv", "text/csv")


if _name_ == "_main_":
    main()
