import streamlit as st
import numpy as np
import pandas as pd
import plotly.express as px

# -------- Fonctions de calcul --------
def allocate_steps(weights, lower, upper, sigma):
    """
    Distribution gloutonne d'un total sigma sur des variables bornées,
    en favorisant celles ayant les plus grands poids.
    """
    n = len(weights)
    allocation = lower.copy().astype(float)
    remaining = sigma - allocation.sum()
    # Indices triés par poids décroissant
    idx_sorted = np.argsort(weights)[::-1]
    for i in idx_sorted:
        if remaining <= 0:
            break
        cap = upper[i] - lower[i]
        delta = min(cap, remaining)
        allocation[i] += delta
        remaining -= delta
    return allocation


def compute_matrix(alpha, beta):
    """
    Construit M selon :
    M[0,0] = 0
    M[0,j] = M[0,j-1] + beta[j]
    M[i,j] = M[i-1,j] + alpha[i]
    (on indexe alpha et beta à partir de 0)
    """
    I = len(alpha)
    J = len(beta)
    M = np.zeros((I, J))
    # première ligne (i=0)
    for j in range(1, J):
        M[0, j] = M[0, j-1] + beta[j]
    # reste
    for i in range(1, I):
        for j in range(J):
            M[i, j] = M[i-1, j] + alpha[i]
    return M

# -------- Interface Streamlit --------
st.title("Matrice de Majoration")

# Entrée utilisateur pour le coef maximal σ
sigma = st.number_input("Coefficient maximal σ (M₁₀,₂₀)", min_value=0.0, value=100.0)

# Poids par défaut (plus le segment est élevé, plus on veut majorer)
alpha_weights = np.arange(1, 11)  # pour 10 segments de concrétisation
beta_weights  = np.arange(1, 21)  # pour 20 segments ELR

# Bornes globales ajustables via la sidebar
st.sidebar.header("Bornes pour α et β")
min_alpha = st.sidebar.number_input("Min α_i", min_value=0.0, value=0.0)
max_alpha = st.sidebar.number_input("Max α_i", min_value=0.0, value=sigma)
min_beta  = st.sidebar.number_input("Min β_j", min_value=0.0, value=0.0)
max_beta  = st.sidebar.number_input("Max β_j", min_value=0.0, value=sigma)

# Construction des vecteurs de bornes
lower_alpha = np.full(10, min_alpha)
upper_alpha = np.full(10, max_alpha)
lower_beta  = np.full(20, min_beta)
upper_beta  = np.full(20, max_beta)

# Calcul des pas α et β
alpha = allocate_steps(alpha_weights, lower_alpha, upper_alpha, sigma)
beta  = allocate_steps(beta_weights,  lower_beta,  upper_beta,  sigma)

# Construction de la matrice M
M = compute_matrix(alpha, beta)

# Affichage sous forme de DataFrame
df = pd.DataFrame(
    M,
    index=[f"i={i+1}" for i in range(M.shape[0])],
    columns=[f"j={j+1}" for j in range(M.shape[1])]
)
st.subheader("Matrice des coefficients M_{i,j}")
st.dataframe(df)

# Affichage heatmap interactif
fig = px.imshow(
    M,
    labels={"x": "ELR segments (j)", "y": "Concrétisation segments (i)", "color": "M"},
    x=df.columns,
    y=df.index,
    aspect="auto"
)
st.subheader("Heatmap de la matrice")
st.plotly_chart(fig)

# Affichage des vecteurs α et β
st.sidebar.subheader("Pas calculés α_i")
st.sidebar.write(alpha)
st.sidebar.subheader("Pas calculés β_j")
st.sidebar.write(beta)
