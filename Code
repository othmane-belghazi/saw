# optim_spline.py
# ---------------------------------------------------------------
# Optimisation d'une surface de majoration 20 x 10 via Bâ€‘splines
# sous contraintes mÃ©tier (zone verte/rouge + monotonie).
# ---------------------------------------------------------------
import pathlib
import numpy as np
import pandas as pd
import cvxpy as cp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

# ---------------------------------------------------------------
# 0.  ParamÃ©trage
# ---------------------------------------------------------------
CSV_PATH = pathlib.Path("data.csv")     # donnÃ©es source
LAMBDA    = 100.0                      # paramÃ¨tre de lissage
# bornes mÃ©tier
MAX_RATE  = 0.25                       # +25Â % plafond
GREEN_MAX = 0.01                       # +1Â % zone verte
RED_MIN   = 0.020408                   # +2,04Â % zone rouge

n_i, n_j = 20, 10                      # dimensions grille

# ---------------------------------------------------------------
# 1.  Lecture (ou crÃ©ation) du fichier data.csv
# ---------------------------------------------------------------
if CSV_PATH.exists():
    df = pd.read_csv(CSV_PATH)
else:
    # jeu fictif minimalÂ â€“Â remplacez par vos vraies donnÃ©es
    rng = np.random.default_rng(0)
    df = pd.DataFrame({
        "activity_id": np.arange(1, 1_001),
        "group_ELR":   rng.integers(1, n_i+1, 1_000),
        "group_CR":    rng.integers(1, n_j+1, 1_000),
        "tariff":      rng.uniform(300, 1_000, 1_000)
    })
    df.to_csv(CSV_PATH, index=False)
    print("ðŸš© Exemple data.csv crÃ©Ã©Â ; remplacez-le par vos donnÃ©es rÃ©elles.")

# poidsÂ : primes par cellule (agrÃ©gÃ©es)
pivot = df.pivot_table(index="group_ELR",
                       columns="group_CR",
                       values="tariff",
                       aggfunc="sum",
                       fill_value=0.0)
W = pivot.to_numpy()                   # shape (20,10)

# ---------------------------------------------------------------
# 2.  Table brute (iciÂ 0)Â â€“Â remplacez si vous avez une premiÃ¨re grille
# ---------------------------------------------------------------
m_hat = np.zeros((n_i, n_j))

# ---------------------------------------------------------------
# 3.  Variable spline et objectif
# ---------------------------------------------------------------
theta = cp.Variable((n_i, n_j))        # taux de majoration Ã  estimer

fidelity = cp.sum_squares(cp.multiply(np.sqrt(W), theta - m_hat))

def second_diff(mat, axis):
    """DeuxiÃ¨me diffÃ©rence discrÃ¨te (cvxpy)."""
    return mat[2:, :] - 2*mat[1:-1, :] + mat[:-2, :] if axis == 0 \
        else mat[:, 2:] - 2*mat[:, 1:-1] + mat[:, :-2]

smooth_pen = cp.sum_squares(second_diff(theta, 0)) \
           + cp.sum_squares(second_diff(theta, 1))

objective = cp.Minimize(fidelity + LAMBDA * smooth_pen)

# ---------------------------------------------------------------
# 4.  Contraintes
# ---------------------------------------------------------------
cons = [
    theta >= 0,
    theta <= MAX_RATE,
    theta[:8, :]  <= GREEN_MAX,        # zone verte
    theta[10:, :] >= RED_MIN,          # zone rouge
    theta[1:, :]  - theta[:-1, :] >= 0,  # monotone en i
    theta[:, 1:]  - theta[:, :-1] >= 0   # monotone en j
]

# ---------------------------------------------------------------
# 5.  RÃ©solution
# ---------------------------------------------------------------
prob = cp.Problem(objective, cons)
prob.solve(solver=cp.OSQP, verbose=True)

print(f"StatutÂ : {prob.status}")
print(f"Valeur obj (penalisÃ©e)Â : {prob.value:.4e}")

M = theta.value                      # matrice optimisÃ©e

# ---------------------------------------------------------------
# 6.  Export & aperÃ§u
# ---------------------------------------------------------------
pd.DataFrame(M,
             index=[f"i{i+1}" for i in range(n_i)],
             columns=[f"j{j+1}" for j in range(n_j)]
).to_csv("maj_spline.csv", float_format="%.5f")
print("âœ… matrice enregistrÃ©e sous maj_spline.csv")
print("AperÃ§u premiÃ¨res lignesÂ :")
print(pd.DataFrame(M).round(4).head())

# ---------------------------------------------------------------
# 7.  Plot 3â€‘D
# ---------------------------------------------------------------
X, Y = np.meshgrid(np.arange(1, n_j+1), np.arange(1, n_i+1))
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X, Y, M, cmap='viridis', linewidth=0)
ax.set_xlabel("Segment conversionÂ (j)")
ax.set_ylabel("Segment ELRÂ (i)")
ax.set_zlabel("Taux de majoration")
ax.set_title("Surface de majoration â€“Â splines bicubiques")
plt.tight_layout()
plt.show()
