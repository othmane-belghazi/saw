from scipy.optimize import Bounds

# Borne minimale et maximale pour Mjk
M_min, M_max = 0.5, 2.0

# Fonction de calcul de Mjk avec bornes
def constraint_Mjk(params, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon):
    alpha, beta, k = params
    M_jk = ((segments_conversion / n_conversion) ** alpha) * \
           ((segments_ELR / n_ELR) ** beta) * \
           (1 - k * epsilon)
    return np.clip(M_jk, M_min, M_max)  # Clip pour respecter les bornes

# Adapter la fonction de majoration moyenne pour respecter les bornes
def majoration_moyenne_borne(params, T, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon):
    M_jk = constraint_Mjk(params, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon)
    numerateur = np.sum(T * M_jk)
    denominateur = np.sum(T)
    return numerateur / denominateur

# Fonction objectif mise à jour
def objectif_borne(params, T, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon, majoration_cible):
    majoration = majoration_moyenne_borne(params, T, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon)
    return (majoration - majoration_cible) ** 2

# Optimisation avec des bornes pour les paramètres
bounds_params = [(0.1, 10), (0.1, 10), (0, 2)]  # Bornes pour alpha, beta, k

result_borne = minimize(
    objectif_borne,
    params_init_adjusted,
    args=(T, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon, majoration_cible),
    bounds=bounds_params,
    method='L-BFGS-B'
)

# Résultats après optimisation avec bornes
optimized_params_borne = result_borne.x
optimized_majoration_borne = majoration_moyenne_borne(
    optimized_params_borne, T, segments_conversion, segments_ELR, n_conversion, n_ELR, epsilon
)

optimized_params_borne, optimized_majoration_borne
