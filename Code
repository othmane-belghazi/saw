# -*- coding: utf-8 -*-
"""
Tarification – Optimisation des paramètres (alpha, beta)
pour la surface de majoration sigmoïde croisée.

Hypothèses :
* M_max, c_i, c_j fixés (métier)
* Données d’entrée déjà chargées dans un DataFrame `df` avec les colonnes :
    - activity_id   : identifiant
    - group_ELR     : segment ELR (1–20)
    - group_CR      : segment concrétisation (1–10)
    - tariff        : tarif de base (prime commerciale)

Objectif : atteindre une surcharge moyenne cible mu_cible
sous contraintes :
    - segments ELR 1–8 : majoration ≤ 1 %
    - segments ELR 11–20 : majoration ≥ 2,04 %

Méthode : Differential Evolution (global) + SLSQP (local).
"""

# ---------------------------------------------------------------------------
# 1. Imports et lecture des données
# ---------------------------------------------------------------------------
import numpy as np
import pandas as pd
from scipy.optimize import differential_evolution, minimize

# df = pd.read_csv('data.csv')  # <-- décommentez et ajustez le chemin
assert {'group_ELR', 'group_CR', 'tariff'}.issubset(df.columns), "Colonnes manquantes dans le DataFrame !"

i_k = df['group_ELR'].to_numpy(int)  # shape (K,)
j_k = df['group_CR'].to_numpy(int)
P    = df['tariff'].to_numpy(float)

# ---------------------------------------------------------------------------
# 2. Paramètres fixes (métier)
# ---------------------------------------------------------------------------
M_max = 0.25      # +25 % maximal
c_i   = 12.5      # centre ELR
c_j   = 6.5       # centre concrétisation
mu_cible = 0.05   # +5 % moyenne cible

bounds = [(0.05, 2.0),   # alpha
          (0.05, 1.5)]   # beta

I = np.arange(1, 21)[:, None]  # (20,1)
J = np.arange(1, 11)[None, :]  # (1,10)

# ---------------------------------------------------------------------------
# 3. Fonctions utilitaires
# ---------------------------------------------------------------------------

def sigmoid(z):
    return 1 / (1 + np.exp(-z))


def m_matrix(alpha, beta):
    s_i = sigmoid(alpha * (I - c_i))
    s_j = sigmoid(beta  * (J - c_j))
    return M_max * s_i * s_j


def mean_surcharge(alpha, beta):
    m = m_matrix(alpha, beta)
    F_k = 1 + m[i_k - 1, j_k - 1]
    return (P @ F_k) / P.sum() - 1.0


def m_8_10(alpha, beta):
    return m_matrix(alpha, beta)[7, 9]


def m_11_1(alpha, beta):
    return m_matrix(alpha, beta)[10, 0]

# ---------------------------------------------------------------------------
# 4. Objectif et contraintes
# ---------------------------------------------------------------------------

def objective(x):
    diff = mean_surcharge(*x) - mu_cible
    return diff * diff

cons = [
    {'type': 'ineq', 'fun': lambda x: 0.01 - m_8_10(*x)},
    {'type': 'ineq', 'fun': lambda x: m_11_1(*x) - 0.020408}
]

# ---------------------------------------------------------------------------
# 5. Differential Evolution (global)
# ---------------------------------------------------------------------------

def penalized_obj(x):
    if (m_8_10(*x) > 0.01) or (m_11_1(*x) < 0.020408):
        return 1e6
    return objective(x)

res_de = differential_evolution(penalized_obj, bounds=bounds, popsize=30, maxiter=40, seed=42)
print(f"DE: alpha≈{res_de.x[0]:.4f}, beta≈{res_de.x[1]:.4f}, obj={res_de.fun:.3e}")

# ---------------------------------------------------------------------------
# 6. SLSQP local (raffinement)
# ---------------------------------------------------------------------------
res_local = minimize(objective, x0=res_de.x, method='SLSQP', bounds=bounds, constraints=cons,
                     options={'ftol': 1e-12, 'maxiter': 300})

alpha_opt, beta_opt = res_local.x
print("\n=== Solution finale ===")
print(f"alpha* = {alpha_opt:.4f}")
print(f"beta*  = {beta_opt:.4f}")
print(f"moy. surcharge = {mean_surcharge(alpha_opt, beta_opt):.4%}")
print(f"m(8,10) = {m_8_10(alpha_opt, beta_opt):.4%}")
print(f"m(11,1) = {m_11_1(alpha_opt, beta_opt):.4%}")

# ---------------------------------------------------------------------------
# 7. Export (facultatif)
# ---------------------------------------------------------------------------
# m_full = m_matrix(alpha_opt, beta_opt)
# df['factor_opt']  = 1 + m_full[i_k-1, j_k-1]
# df['tariff_new']  = df['tariff'] * df['factor_opt']
# df.to_csv('tariff_after_optim.csv', index=False)
