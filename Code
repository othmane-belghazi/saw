# %% [markdown]
# üü¢ 1. Imports et param√®tres globaux

import numpy as np
import pandas as pd
from scipy.optimize import differential_evolution
from functools import partial

# param√®tres √† ajuster
lambda_elr = 1.0
lambda_vol = 1.0
x_min, x_max = 0.0, 0.08
max_iter = 60
random_state = 42

# si le mod√®le EBM est d√©j√† charg√© :
# import pickle
# with open('ebm_model.pkl','rb') as f:
#     ebm_model = pickle.load(f)


# %% [markdown]
# üü¢ 2. V√©rification de la donn√©e de base `df`

cols_requis = ['numcontrat','activity_code','PC','PP','surface','type_client','local','chiffre_affaires']
if 'df' not in globals():
    raise RuntimeError("‚ö†Ô∏è La DataFrame 'df' doit √™tre d√©j√† charg√©e en m√©moire.")
if any(c not in df.columns for c in cols_requis):
    raise RuntimeError(f"Colonnes manquantes : {set(cols_requis) - set(df.columns)}")

# liste des activit√©s
activites = sorted(df['activity_code'].unique().tolist())
n = len(activites)

# regroupement par activit√©
df_act = {act: df[df['activity_code'] == act].reset_index(drop=True) for act in activites}

##############################


# %% [markdown]
# üü¢ 3. Calcul des valeurs initiales : ELR global et volumes initiaux

gwp_tot = 0
pp_tot = 0
elr_par_act = {}
n_init = {}

for act in activites:
    data = df_act[act].copy()
    f0 = ebm_model.predict_proba(data)[:,1]
    f0 = np.clip(f0,0,1)
    pc = data['PC'].values
    pp = data['PP'].values
    
    gwp_i = np.sum(pc * f0)
    pp_i = np.sum(pp * f0)
    n_i = np.sum(f0)
    
    gwp_tot += gwp_i
    pp_tot += pp_i
    elr_par_act[act] = pp_i / gwp_i if gwp_i>0 else np.inf
    n_init[act] = n_i

elr_global = pp_tot / gwp_tot
print(f"ELR produit global initial : {elr_global:.4f}")



# %% [markdown]
# üü¢ 4. Fonction objectif S(X) sans utiliser def (√©crite inline dans la boucle d'optimisation)

# on cr√©e une fonction lambda pour differential_evolution
# cette fonction calcule -S(X) (car l'algo minimise)

def objectif(x_vect):
    total_gwp = 0
    pen_elr = 0
    pen_vol = 0
    
    for idx, act in enumerate(activites):
        x_i = float(x_vect[idx])
        data = df_act[act].copy()
        
        # appliquer majoration sur la prime
        data['PC_mod'] = data['PC'] * (1 + x_i)
        f = ebm_model.predict_proba(data)[:,1]
        f = np.clip(f,0,1)
        
        pc = data['PC_mod'].values
        pp = data['PP'].values
        
        gwp_i = np.sum(pc * f)
        pp_i = np.sum(pp * f)
        n_i = np.sum(f)
        
        elr_i = pp_i / gwp_i if gwp_i>0 else np.inf
        
        total_gwp += gwp_i
        
        # p√©nalisation ELR
        depassement = max(0, elr_i - elr_global)
        pen_elr += depassement * gwp_i
        
        # p√©nalisation volume
        seuil = 0.95 * n_init[act]
        pen_vol += max(0, seuil - n_i)
    
    s = total_gwp - lambda_elr*pen_elr - lambda_vol*pen_vol
    return -s  # on minimise -S





# %% [markdown]
# üü¢ 5. Lancement de l'optimisation

bornes = [(x_min, x_max) for _ in range(n)]

resultat = differential_evolution(
    objectif,
    bounds=bornes,
    maxiter=max_iter,
    seed=random_state,
    polish=True
)

x_opt = resultat.x
print("‚úÖ Optimisation termin√©e.")
print(f"Score objectif : {-resultat.fun:.2f}")
print("Majorations optimales par activit√© :")
for act, x in zip(activites, x_opt):
    print(f"  {act} ‚Üí {x*100:.2f}%")




# %% [markdown]
# üü¢ 6. Calcul des indicateurs finaux par activit√© apr√®s optimisation

res = []
for idx, act in enumerate(activites):
    x_i = float(x_opt[idx])
    data = df_act[act].copy()
    data['PC_mod'] = data['PC'] * (1 + x_i)
    f = ebm_model.predict_proba(data)[:,1]
    f = np.clip(f,0,1)
    
    gwp_i = np.sum(data['PC_mod'] * f)
    pp_i = np.sum(data['PP'] * f)
    n_i = np.sum(f)
    elr_i = pp_i / gwp_i if gwp_i>0 else np.inf
    
    res.append({
        'activity_code': act,
        'x_i': x_i,
        'gwp_i': gwp_i,
        'pp_i': pp_i,
        'n_i': n_i,
        'elr_i': elr_i
    })

df_res = pd.DataFrame(res).sort_values('activity_code').reset_index(drop=True)
display(df_res)
print(f"GWP total optimis√© : {df_res['gwp_i'].sum():.2f}")


