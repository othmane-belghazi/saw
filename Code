import pandas as pd
import numpy as np
from ortools.linear_solver import pywraplp

# ==============================================================================
# 1. CHARGEMENT DES DONNÉES (Simulation selon ta structure)
# ==============================================================================

# A. BASE PORTEFEUILLE (Historique pour calculer l'ELR)
# Contient : contrat, prime_pure, prime_commerciale, activite
n_pf = 2000
data_pf = {
    'contrat_id': range(n_pf),
    'activite': np.random.choice(['Boulangerie', 'BTP', 'Bureau', 'Commerce'], n_pf),
    'prime_commerciale': np.random.uniform(1000, 3000, n_pf)
}
df_pf = pd.DataFrame(data_pf)

# On simule la Prime Pure en fonction de l'activité (Le BTP est plus risqué)
def simuler_prime_pure(row):
    ratio = 0.90 if row['activite'] == 'BTP' else 0.40 # BTP très cher, Bureau très rentable
    # On ajoute du bruit aléatoire (variance du risque)
    return row['prime_commerciale'] * ratio * np.random.normal(1, 0.1)

df_pf['prime_pure'] = df_pf.apply(simuler_prime_pure, axis=1)


# B. BASE DEVIS (Nouvelles affaires)
# Contient : contrat, prime_commerciale, activite, surface, local, capital, ca
n_devis = 100
data_devis = {
    'devis_id': range(n_devis),
    'activite': np.random.choice(['Boulangerie', 'BTP', 'Bureau', 'Commerce'], n_devis),
    'prime_commerciale': np.random.uniform(1000, 3000, n_devis),
    'surface': np.random.randint(50, 500, n_devis),
    'local': np.random.choice(['Paris', 'Lyon', 'Marseille', 'Autre'], n_devis),
    'capital_incendie': np.random.uniform(50000, 500000, n_devis),
    'chiffre_affaires': np.random.uniform(100000, 1000000, n_devis)
}
df_devis = pd.DataFrame(data_devis)

print(">>> Données chargées.")

# ==============================================================================
# 2. CALCUL ACTUARIEL & INFERENCE
# ==============================================================================

# --- Calcul de l'ELR par Activité sur le Portefeuille ---
# Formule : Somme(Pure) / Somme(Commerciale)
elr_ref = df_pf.groupby('activite').apply(
    lambda x: x['prime_pure'].sum() / x['prime_commerciale'].sum()
).reset_index(name='elr_activite')

print("\n>>> ELR calculés par activité (Base Portefeuille) :")
print(elr_ref)

# --- Projection sur les Devis ---
df_model = df_devis.merge(elr_ref, on='activite', how='left')

# Calcul du Coût Technique Estimé (CONSTANTE pour l'optimisation)
df_model['cout_technique_estime'] = df_model['prime_commerciale'] * df_model['elr_activite']

# --- Segmentation (Bornes) ---
def get_bounds(elr):
    if elr < 0.30: return 0.00, 0.005
    elif 0.30 <= elr < 0.50: return 0.005, 0.010
    elif 0.50 <= elr < 0.80: return 0.020, 0.040 # Moyenne produit approx
    else: return 0.050, 0.100 # Mauvais risques

df_model[['min_h', 'max_h']] = df_model['elr_activite'].apply(lambda x: pd.Series(get_bounds(x)))

# ==============================================================================
# 3. GÉNÉRATION SCÉNARIOS & APPEL EBM
# ==============================================================================

# Fonction Mock pour simuler ton modèle EBM
def call_ebm_prediction(features_dict):
    """
    Simule ton modèle : model.predict_proba(X)
    Variables utilisées : prime, activite, surface, local, capital, ca
    """
    base_score = 0.4
    
    # Sensibilité prix (plus le prix est haut par rapport au CA, plus la proba baisse)
    ratio_prix = features_dict['prime_commerciale'] / features_dict['chiffre_affaires']
    impact_prix = -50 * ratio_prix 
    
    # Impact BTP (plus dur à assurer, donc proba reste haute même si cher)
    impact_act = 0.1 if features_dict['activite'] == 'BTP' else 0
    
    proba = base_score + impact_prix + impact_act
    return max(0.01, min(0.99, proba)) # Clip entre 0 et 1

scenarios = []

print("\n>>> Génération des scénarios et scoring EBM...")

# Calcul de la proba initiale (sans hausse) pour la contrainte de volume
# On stocke ça pour plus tard
proba_base_map = {} 

for idx, row in df_model.iterrows():
    
    # 1. Calcul Proba Base (Hausse 0%)
    feats_base = {
        'prime_commerciale': row['prime_commerciale'], # Prix initial
        'activite': row['activite'],
        'surface': row['surface'],
        'local': row['local'],
        'capital_incendie': row['capital_incendie'],
        'chiffre_affaires': row['chiffre_affaires']
    }
    p_base = call_ebm_prediction(feats_base)
    proba_base_map[row['devis_id']] = p_base
    
    # 2. Génération des hausses possibles
    steps = np.linspace(row['min_h'], row['max_h'], 5)
    
    for hausse in steps:
        new_prime = row['prime_commerciale'] * (1 + hausse)
        
        # On met à jour SEULEMENT la prime dans les features
        feats_scen = feats_base.copy()
        feats_scen['prime_commerciale'] = new_prime
        
        # Prédiction EBM avec le nouveau prix
        proba_new = call_ebm_prediction(feats_scen)
        
        # Calcul de la MARGE ESPERÉE
        # (Prix Vendu - Coût Risque Estimé) * Proba Vente
        marge = (new_prime - row['cout_technique_estime']) * proba_new
        
        scenarios.append({
            'devis_id': row['devis_id'],
            'prime_init': row['prime_commerciale'],
            'hausse': hausse,
            'new_prime': new_prime,
            'proba_new': proba_new,
            'marge_esperee': marge
        })

df_scen = pd.DataFrame(scenarios)

# ==============================================================================
# 4. OPTIMISATION (OR-TOOLS)
# ==============================================================================
solver = pywraplp.Solver.CreateSolver('SCIP')

# Variables binaires x[index_du_scenario]
x = {}
for i in df_scen.index:
    x[i] = solver.BoolVar(f'x_{i}')

# C1. Unicité
for d_id, group in df_scen.groupby('devis_id'):
    solver.Add(solver.Sum([x[i] for i in group.index]) == 1)

# C2. Volume (> 90% du volume initial espéré)
vol_base_total = sum(proba_base_map.values())
current_vol = solver.Sum([row['proba_new'] * x[i] for i, row in df_scen.iterrows()])
solver.Add(current_vol >= 0.90 * vol_base_total)

# C3. Majoration Moyenne Cible (Vision Offre)
# 3.8% <= Somme(PrimeInit * Hausse) / Somme(PrimeInit) <= 4.2%
total_prime_init = df_model['prime_commerciale'].sum()
weighted_increase = solver.Sum(
    [row['prime_init'] * row['hausse'] * x[i] for i, row in df_scen.iterrows()]
)
solver.Add(weighted_increase >= 0.038 * total_prime_init)
solver.Add(weighted_increase <= 0.042 * total_prime_init)

# OBJECTIF : Maximiser la Marge Totale
solver.Maximize(
    solver.Sum([row['marge_esperee'] * x[i] for i, row in df_scen.iterrows()])
)

print("\n>>> Résolution en cours...")
status = solver.Solve()

# ==============================================================================
# 5. RÉSULTATS
# ==============================================================================
if status == pywraplp.Solver.OPTIMAL:
    print(f"\n>>> OPTIMUM TROUVÉ ! Marge Espérée Totale : {solver.Objective().Value():,.0f} €")
    
    # Récupération des choix
    idx_retenus = [i for i in x if x[i].solution_value() > 0.5]
    final_df = df_scen.loc[idx_retenus].copy()
    
    # Merge pour analyse (récupérer activite et elr)
    final_df = final_df.merge(df_model[['devis_id', 'activite', 'elr_activite']], on='devis_id')
    
    # Indicateurs
    avg_hausse = (final_df['prime_init'] * final_df['hausse']).sum() / final_df['prime_init'].sum()
    retention = final_df['proba_new'].sum() / vol_base_total
    
    print(f"Majoration Moyenne (Offre) : {avg_hausse:.2%}")
    print(f"Rétention Volume (Prévue)  : {retention:.1%}")
    
    print("\n--- Analyse par Activité ---")
    summary = final_df.groupby('activite').agg({
        'elr_activite': 'mean',   # Pour voir le risque
        'hausse': 'mean',         # La sanction tarifaire
        'proba_new': 'mean'       # La réaction client
    }).sort_values('hausse', ascending=False)
    
    print(summary)
    # Tu devrais voir que les activités à haut ELR ont les plus fortes hausses
    
else:
    print("Pas de solution optimale trouvée.")
