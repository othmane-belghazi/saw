# Install cvxpy if not available (commented out; for Colab you might need !pip install cvxpy)
# !pip install cvxpy

import numpy as np
import pandas as pd
import cvxpy as cp
import matplotlib.pyplot as plt
import ace_tools as tools

# --- 1. Dimensions ----------------------------------------------------------
n_i, n_j = 20, 10            # segments ELR × segments Conversion
I = np.arange(n_i)
J = np.arange(n_j)

# --- 2. Initial "rough" table (here: all zeros) -----------------------------
# If you have a historic table, replace `m_hat` by that matrix
m_hat = np.zeros((n_i, n_j))

# --- 3. Optimisation variables ---------------------------------------------
theta = cp.Variable((n_i, n_j))

# --- 4. Fidelity term -------------------------------------------------------
# weights (here: 1 everywhere; could be proportional to premiums)
W = np.ones((n_i, n_j))
fidelity = cp.sum_squares(cp.multiply(np.sqrt(W), theta - m_hat))

# --- 5. Smoothness penalty: 2nd differences on both axes -------------------
def second_diff(mat, axis=0):
    """Return second finite difference along axis for a cp Variable."""
    if axis == 0:
        return mat[2:, :] - 2 * mat[1:-1, :] + mat[:-2, :]
    else:
        return mat[:, 2:] - 2 * mat[:, 1:-1] + mat[:, :-2]

penalty = cp.sum_squares(second_diff(theta, axis=0)) + cp.sum_squares(second_diff(theta, axis=1))

lam = 100.0   # smoothing hyper‑parameter
objective = cp.Minimize(fidelity + lam * penalty)

# --- 6. Constraints ---------------------------------------------------------
constraints = []

# Zone verte: i <= 7 --> m <= 0.01
constraints.append(theta[:8, :] <= 0.01)

# Zone rouge: i >= 10 --> m >= 0.020408
constraints.append(theta[10:, :] >= 0.020408)

# Optional monotonicity on ELR axis (non‑decreasing)
constraints.append(theta[1:, :] - theta[:-1, :] >= 0)

# Optional monotonicity on conversion axis (non‑decreasing)
constraints.append(theta[:, 1:] - theta[:, :-1] >= 0)

# Upper bound for stability (<= 0.25)
constraints.append(theta <= 0.25)
constraints.append(theta >= 0)  # No negative majoration

# --- 7. Solve --------------------------------------------------------------
prob = cp.Problem(objective, constraints)
prob.solve(solver=cp.OSQP, verbose=False)

print("Optimisation status:", prob.status)
print("Objective value (penalised):", prob.value)

M_opt = theta.value

# --- 8. Display matrix -----------------------------------------------------
df_M = pd.DataFrame(M_opt, index=[f"i={i+1}" for i in range(n_i)],
                    columns=[f"j={j+1}" for j in range(n_j)])
tools.display_dataframe_to_user("Matrice_M_spline", df_M)

# --- 9. 3D surface plot ----------------------------------------------------
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401

X, Y = np.meshgrid(np.arange(1, n_j+1), np.arange(1, n_i+1))  # X=j, Y=i

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, M_opt, rstride=1, cstride=1, linewidth=0, antialiased=False)
ax.set_xlabel("Segment conversion (j)")
ax.set_ylabel("Segment ELR (i)")
ax.set_zlabel("Taux de majoration")
ax.set_title("Surface de majoration spline lissée")
plt.tight_layout()
plt.show()
