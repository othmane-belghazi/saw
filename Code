from interpret.glassbox import ExplainableBoostingClassifier
import numpy as np
import pandas as pd

# --- Features prix ---
df['log_price'] = np.log1p(df['prix'])

grp = df.groupby(['Formule', 'Activité', 'TypeClient'])
med_seg = grp['prix'].transform('median')
q95_seg = grp['prix'].transform(lambda s: s.quantile(0.95))

df['prix_rel'] = df['prix'] / med_seg - 1.0
df['price_excess'] = (df['prix'] - q95_seg).clip(lower=0)

# Hinges optionnels
for q in [0.7, 0.85, 0.95]:
    q_seg = grp['prix'].transform(lambda s, qq=q: s.quantile(qq))
    df[f'hinge_{int(q*100)}'] = (df['prix'] - q_seg).clip(lower=0)

# Option B (masques par Formule), si vous ne forcez pas d'interactions :
for f in df['Formule'].unique():
    df[f'price_formule_{f}'] = df['prix'] * (df['Formule'] == f)

# Monotonicité : -1 pour toutes les features liées au prix
mono = {
    'log_price': -1,
    'prix_rel': -1,
    'price_excess': -1,
    'hinge_70': -1, 'hinge_85': -1, 'hinge_95': -1,
    # + une entrée -1 pour chaque price_formule_* si vous utilisez les masques
}

# Pondération (upweight queues hautes)
price_pct = pd.qcut(df['prix'], 10, labels=False) / 9.0
w = 0.5 + 1.5 * price_pct

features = [
    # numériques/catégorielles existantes...
    'PôleID', 'Formule', 'Activité', 'TypeClient', 'TypeLocal',
    'Surface_bins', 'CA_bins', 'Capital_incendie_bins',
    # prix
    'log_price', 'prix_rel', 'price_excess', 'hinge_85', 'hinge_95',
    # ou: features masquées par segment si pas d'interactions
    # *et* retirez alors 'interactions' ci-dessous
]

ebm = ExplainableBoostingClassifier(
    max_bins=512,
    max_leaves=8,
    min_samples_leaf=2,
    outer_bags=6,
    inner_bags=0,                 # allège le sur-lissage
    learning_rate=0.05,
    interactions=6,               # si vous forcez des interactions prix×segments
    max_interaction_bins=256,
    monotone_constraints=mono,
    validation_size=0.1,
    early_stopping_rounds=300,
    n_jobs=-1,
    random_state=42
)

X = df[features]
y = df['conversion']
ebm.fit(X, y, sample_weight=w)

# Après entraînement : contrôles d'élasticité / monotonicité / ICE
