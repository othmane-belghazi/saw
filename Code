import pandas as pd
import numpy as np
from ortools.linear_solver import pywraplp
import matplotlib.pyplot as plt
import seaborn as sns

# ==============================================================================
# 1. CONFIGURATION DES VARIABLES (Mapping)
# ==============================================================================

# Noms des colonnes selon ta demande
COL_PF_ID = 'Contrat'
COL_PF_COUT = 'COPTTC'               # Le numérateur de l'ELR (Sinistre/Charge)
COL_PF_PRIME = 'tarif_vendu_ht_sansFR' # Le dénominateur (Prime Commerciale)
COL_PF_ACT = 'Activite'

COL_DEV_ID = 'numcnt'
COL_DEV_PRIME = 'tarif_vendu_ht_sansFR' # Je suppose que c'est le même nom que dans le PF
COL_DEV_ACT = 'activite' # Attention à la casse (majuscule/minuscule)

# Liste exacte des features que ton modèle EBM attend (ordre important !)
# Assure-toi que les noms matchent ceux de df_devis
FEATURES_EBM = [
    'tarif_vendu_ht_sansFR', # C'est cette variable qu'on va faire bouger
    'activite', 
    'type_client', 
    'produit', 
    'surface_bins', 
    'chiffre_affaires_bins', 
    'type_occupation_local', 
    'cop_ttc', 
    'reduction', 
    'capital_incendie_bins'
]

# ==============================================================================
# 2. CALCUL DE L'ELR (Depuis le Portefeuille)
# ==============================================================================
print(">>> Calcul des ELR par activité...")

# On groupe par activité pour avoir la performance historique
elr_ref = df_pf.groupby(COL_PF_ACT)[[COL_PF_COUT, COL_PF_PRIME]].sum().reset_index()
elr_ref['elr_segment'] = elr_ref[COL_PF_COUT] / elr_ref[COL_PF_PRIME]

# On gère les divisions par zéro ou les segments vides
elr_ref['elr_segment'] = elr_ref['elr_segment'].fillna(1.0) # Valeur par défaut prudente

# ==============================================================================
# 3. PRÉPARATION DES DONNÉES DEVIS & SCÉNARIOS
# ==============================================================================
print(">>> Préparation des scénarios et Prédiction EBM...")

# A. Jointure pour récupérer l'ELR sur les devis
# Attention : on s'assure que la colonne de jointure a le même nom
df_model = df_devis.merge(
    elr_ref[[COL_PF_ACT, 'elr_segment']], 
    left_on=COL_DEV_ACT, 
    right_on=COL_PF_ACT, 
    how='left'
)

# Si activité inconnue dans le PF, on met un ELR par défaut (ex: moyenne globale)
mean_elr = elr_ref['elr_segment'].mean()
df_model['elr_segment'] = df_model['elr_segment'].fillna(mean_elr)

# B. Calcul du Coût Technique Estimé (C_i) - CONSTANTE
# C'est la Prime Pure estimée : Prime Actuelle * ELR Historique
df_model['cout_technique'] = df_model[COL_DEV_PRIME] * df_model['elr_segment']

# C. Définition des bornes (Fonction Vectorisée)
conditions = [
    (df_model['elr_segment'] < 0.30),
    (df_model['elr_segment'] >= 0.30) & (df_model['elr_segment'] < 0.50),
    (df_model['elr_segment'] >= 0.50) & (df_model['elr_segment'] < 0.80), # 80% comme pivot moyen
    (df_model['elr_segment'] >= 0.80)
]
choices_min = [0.00,  0.005, 0.02, 0.05]
choices_max = [0.005, 0.01,  0.04, 0.10]

df_model['min_h'] = np.select(conditions, choices_min, default=0.05)
df_model['max_h'] = np.select(conditions, choices_max, default=0.10)

# D. Génération des Scénarios (Batch Prediction pour performance)
scenarios_list = []
input_data_list = [] # Pour stocker les features prêtes pour EBM

for idx, row in df_model.iterrows():
    # On crée 5 pas entre min et max
    steps = np.linspace(row['min_h'], row['max_h'], 5)
    steps = np.unique(steps) # Évite doublons si min=max
    
    for hausse in steps:
        new_prime = row[COL_DEV_PRIME] * (1 + hausse)
        
        # On prépare la ligne de features pour l'EBM
        # On copie les données actuelles du devis
        features = row[FEATURES_EBM].to_dict()
        # ON MET À JOUR LA VARIABLE PRIX
        features['tarif_vendu_ht_sansFR'] = new_prime 
        
        input_data_list.append(features)
        
        scenarios_list.append({
            'devis_id': row[COL_DEV_ID],
            'prime_base': row[COL_DEV_PRIME],
            'hausse': hausse,
            'prime_finale': new_prime,
            'cout_technique': row['cout_technique'],
            'elr_segment': row['elr_segment'], # Pour l'analyse post-hoc
            'activite': row[COL_DEV_ACT]
        })

# E. Appel au Modèle EBM (Batch Prediction)
# On convertit la liste de dicts en DataFrame pour le predict_proba
df_ebm_input = pd.DataFrame(input_data_list)

# --- PRÉDICTION ---
# On récupère la probabilité de la classe 1 (Conversion)
# EBM.predict_proba retourne [Proba_0, Proba_1]
probas_conversion = ebm_model.predict_proba(df_ebm_input)[:, 1]

# On réinjecte les probas dans les scénarios
df_scen = pd.DataFrame(scenarios_list)
df_scen['proba_predite'] = probas_conversion

# Calcul de la Marge Espérée
df_scen['marge_esperee'] = (df_scen['prime_finale'] - df_scen['cout_technique']) * df_scen['proba_predite']

# ==============================================================================
# 4. OPTIMISATION (Google OR-Tools)
# ==============================================================================
print(">>> Lancement de l'optimisation...")

solver = pywraplp.Solver.CreateSolver('SCIP')

# Variables
x = {}
for i in df_scen.index:
    x[i] = solver.BoolVar(f'x_{i}')

# C1. Unicité (Une seule offre par devis)
# Astuce performance : groupby sur index
groups = df_scen.groupby('devis_id').groups
for devis_id, indices in groups.items():
    solver.Add(solver.Sum([x[i] for i in indices]) == 1)

# Calcul du volume de base (proba à hausse 0 ou prix actuel)
# Pour simplifier, on approxime par la somme des probas EBM avec hausse minimale
# ou on refait un predict à 0%. Ici, on utilise la contrainte relative aux scénarios choisis.
# Supposons qu'on veuille garder 90% du potentiel de conversion max de chaque client
# (Approximation safe si on n'a pas calculé la proba exacte à 0% séparément)
max_proba_per_id = df_scen.groupby('devis_id')['proba_predite'].max().sum()
target_vol = 0.90 * max_proba_per_id

solver.Add(solver.Sum([df_scen.loc[i, 'proba_predite'] * x[i] for i in df_scen.index]) >= target_vol)

# C3. Majoration Moyenne (Vision Offre : Pondérée par Prime Initiale)
total_prime_base = df_model[COL_DEV_PRIME].sum()
sum_maj = solver.Sum([df_scen.loc[i, 'prime_base'] * df_scen.loc[i, 'hausse'] * x[i] for i in df_scen.index])

solver.Add(sum_maj >= 0.038 * total_prime_base)
solver.Add(sum_maj <= 0.042 * total_prime_base)

# Objectif : Max Marge
solver.Maximize(solver.Sum([df_scen.loc[i, 'marge_esperee'] * x[i] for i in df_scen.index]))

status = solver.Solve()

# ==============================================================================
# 5. RÉSULTATS & VISUALISATIONS
# ==============================================================================

if status == pywraplp.Solver.OPTIMAL:
    print(">>> Solution Optimale Trouvée !")
    
    # Extraction des données finales
    idx_selected = [i for i in x if x[i].solution_value() > 0.5]
    df_result = df_scen.loc[idx_selected].copy()
    
    # --- KPIs GLOBAUX ---
    gwp_gain = (df_result['prime_finale'] * df_result['proba_predite']).sum()
    marge_gain = df_result['marge_esperee'].sum()
    avg_increase = (df_result['prime_base'] * df_result['hausse']).sum() / df_result['prime_base'].sum()
    
    print(f"Hausse Moyenne Globale : {avg_increase:.2%}")
    print(f"Marge Espérée Totale   : {marge_gain:,.0f} €")

    # ==========================
    # VISUALISATIONS
    # ==========================
    sns.set_theme(style="whitegrid")
    
    # 1. SCATTER PLOT : SANCTION TARIFAIRE SELON LA QUALITÉ DU RISQUE (ELR)
    # On agrège par activité pour que ce soit lisible
    viz_data = df_result.groupby('activite').agg({
        'elr_segment': 'mean',
        'hausse': 'mean',
        'prime_base': 'sum' # Taille de la bulle
    }).reset_index()
    
    plt.figure(figsize=(10, 6))
    scatter = sns.scatterplot(
        data=viz_data, 
        x='elr_segment', 
        y='hausse', 
        size='prime_base', 
        sizes=(100, 1000),
        hue='elr_segment',
        palette='RdYlGn_r', # Rouge pour haut ELR, Vert pour bas ELR
        legend=False
    )
    
    # Ajout d'une ligne moyenne cible
    plt.axhline(y=0.04, color='grey', linestyle='--', label='Cible 4%')
    plt.axvline(x=1.0, color='red', linestyle=':', label='Seuil Rentabilité (100%)')
    
    plt.title("Corrélation : Qualité Technique (ELR) vs Hausse Appliquée", fontsize=14)
    plt.xlabel("Expected Loss Ratio (S/P) de l'Activité", fontsize=12)
    plt.ylabel("Hausse Tarifaire Moyenne", fontsize=12)
    
    # Formatage des axes en %
    scatter.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: '{:.0%}'.format(x)))
    scatter.yaxis.set_major_formatter(plt.FuncFormatter(lambda y, _: '{:.1%}'.format(y)))
    
    # Annotation des points extrêmes
    for i in range(viz_data.shape[0]):
        if viz_data.elr_segment.iloc[i] > 0.8 or viz_data.hausse.iloc[i] > 0.06:
            plt.text(
                viz_data.elr_segment.iloc[i]+0.01, 
                viz_data.hausse.iloc[i], 
                viz_data.activite.iloc[i], 
                fontsize=9
            )
            
    [Image of linear programming feasible region]
    plt.tight_layout()
    plt.show()

    # 2. DISTRIBUTION DES HAUSSES
    plt.figure(figsize=(8, 5))
    sns.histplot(df_result['hausse'], bins=20, kde=True, color='skyblue')
    plt.title("Distribution des Majorations appliquées aux Devis", fontsize=14)
    plt.xlabel("Taux de Majoration", fontsize=12)
    plt.gca().xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: '{:.1%}'.format(x)))
    plt.tight_layout()
    plt.show()

    # 3. IMPACT SUR LA MARGE (Comparaison Avant/Après théorique)
    # Marge Avant = (Prime Base - Cout) * Proba Base (approx via new proba for viz)
    # Note: C'est une approx visuelle
    
    categories = ['Marge Actuelle (Est.)', 'Marge Après Opti.']
    # Simulation marge actuelle : on suppose proba conversion sans hausse un peu plus élevée
    marge_actuelle_simu = (df_result['prime_base'] - df_result['cout_technique']).sum() * (df_result['proba_predite'].mean() * 1.1) 
    values = [marge_actuelle_simu, marge_gain]
    
    plt.figure(figsize=(6, 6))
    bars = plt.bar(categories, values, color=['lightgrey', '#2ecc71'])
    plt.title("Gain d'Optimisation de la Marge", fontsize=14)
    plt.ylabel("Marge Technique Espérée (€)")
    
    # Ajout des valeurs sur les barres
    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2, yval + yval*0.01, f"{yval:,.0f} €", ha='center', va='bottom', fontsize=12, fontweight='bold')
        
    plt.tight_layout()
    plt.show()

else:
    print("Aucune solution trouvée. Vérifiez que les contraintes ne sont pas contradictoires (ex: ELR vs Cible 4%).")
