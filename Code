import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict, NamedTuple
import random
from enum import Enum

class SegmentType(Enum):
    A = "A"  # Haute conversion, Haute rentabilité - Protéger
    B = "B"  # Haute conversion, Faible rentabilité - Majorer fort
    C = "C"  # Faible conversion, Haute rentabilité - Modéré
    D = "D"  # Faible conversion, Faible rentabilité - Décourager

class Individual(NamedTuple):
    """Individu dans la population NSGA-II"""
    majoration_rates: np.ndarray  # Matrice 10x20 des taux de majoration
    objectives: Tuple[float, float] = None  # (profit, conversion_rate)
    rank: int = 0
    crowding_distance: float = 0.0

def setup_problem_parameters(n_conv: int = 10, n_profit: int = 20) -> Dict:
    """Initialise les paramètres du problème d'assurance"""
    
    # Taux de conversion par segment (10 segments)
    C0 = np.array([0.20, 0.35, 0.45, 0.55, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90])
    
    # Taux de rentabilité par segment (20 segments)
    R0 = np.linspace(0.02, 0.20, n_profit)
    
    # Volumes par segment (matrice 10x20)
    np.random.seed(42)
    volumes = np.random.uniform(1000, 10000, (n_conv, n_profit))
    
    # Élasticité prix (matrice 10x20)
    elasticity = np.random.uniform(0.5, 2.0, (n_conv, n_profit))
    
    # Seuils de classification
    theta_C = np.percentile(C0, 70)  # 0.70
    theta_R = np.percentile(R0, 70)  # 0.14
    
    # Classification des segments
    segment_types = classify_segments(C0, R0, theta_C, theta_R, n_conv, n_profit)
    
    # Coefficients de bonus/pénalité
    lambda_A = 10.0  # Pénalise majoration élevée
    lambda_B = 5.0   # Encourage majoration
    lambda_C = 3.0   # Encourage protection
    lambda_D = 8.0   # Encourage forte majoration
    
    return {
        'n_conv': n_conv,
        'n_profit': n_profit,
        'C0': C0,
        'R0': R0,
        'volumes': volumes,
        'elasticity': elasticity,
        'theta_C': theta_C,
        'theta_R': theta_R,
        'segment_types': segment_types,
        'lambda_A': lambda_A,
        'lambda_B': lambda_B,
        'lambda_C': lambda_C,
        'lambda_D': lambda_D
    }

def classify_segments(C0: np.ndarray, R0: np.ndarray, theta_C: float, theta_R: float, 
                     n_conv: int, n_profit: int) -> np.ndarray:
    """Classification des segments selon les formules définies"""
    segments = np.empty((n_conv, n_profit), dtype=object)
    
    for j in range(n_conv):
        for k in range(n_profit):
            if C0[j] >= theta_C and R0[k] >= theta_R:
                segments[j, k] = SegmentType.A
            elif C0[j] >= theta_C and R0[k] < theta_R:
                segments[j, k] = SegmentType.B
            elif C0[j] < theta_C and R0[k] >= theta_R:
                segments[j, k] = SegmentType.C
            else:
                segments[j, k] = SegmentType.D
    
    return segments

def conversion_function(m_jk: float, j: int, k: int, params: Dict) -> float:
    """
    Fonction de conversion avec élasticité: C_{j,k}(m_{j,k}) = C_{j,0} * (1 + m_{j,k})^{-ε_{j,k}}
    """
    return params['C0'][j] * np.power(1 + m_jk, -params['elasticity'][j, k])

def adjusted_profitability(m_jk: float, j: int, k: int, params: Dict) -> float:
    """
    Rentabilité ajustée: R_{j,k}(m_{j,k}) = R_{0,k} + α_{j,k} * m_{j,k} + β_{j,k}(m_{j,k})
    """
    base_profitability = params['R0'][k]
    alpha = 0.1  # Coefficient linéaire
    
    # Bonus/Pénalité selon le type de segment
    segment_type = params['segment_types'][j, k]
    
    if segment_type == SegmentType.A:
        beta = -params['lambda_A'] * m_jk**2  # Pénalise majoration élevée
    elif segment_type == SegmentType.B:
        beta = params['lambda_B'] * m_jk      # Encourage majoration
    elif segment_type == SegmentType.C:
        beta = -params['lambda_C'] * m_jk     # Encourage protection
    else:  # SegmentType.D
        beta = params['lambda_D'] * m_jk**2   # Encourage forte majoration
    
    return base_profitability + alpha * m_jk + beta

def get_bounds(j: int, k: int, params: Dict) -> Tuple[float, float]:
    """Contraintes de bornes selon le type de segment"""
    segment_type = params['segment_types'][j, k]
    
    bounds = {
        SegmentType.A: (0.0, 0.05),    # Protéger
        SegmentType.B: (0.12, 0.30),   # Majorer fort
        SegmentType.C: (0.03, 0.12),   # Modéré
        SegmentType.D: (0.20, 0.40)    # Décourager
    }
    
    return bounds[segment_type]

def evaluate_objectives(majoration_rates: np.ndarray, params: Dict) -> Tuple[float, float]:
    """
    Évalue les deux objectifs:
    f1 = Profit total
    f2 = Taux de conversion global
    """
    m_matrix = majoration_rates.reshape(params['n_conv'], params['n_profit'])
    total_profit = 0.0
    total_weighted_conversion = 0.0
    total_volume = 0.0
    
    for j in range(params['n_conv']):
        for k in range(params['n_profit']):
            m_jk = m_matrix[j, k]
            
            # Calculs selon les formules
            conversion = conversion_function(m_jk, j, k, params)
            profitability = adjusted_profitability(m_jk, j, k, params)
            volume = params['volumes'][j, k]
            
            # Contribution au profit total
            segment_profit = volume * conversion * profitability * (1 + m_jk)
            total_profit += segment_profit
            
            # Contribution à la conversion globale
            total_weighted_conversion += volume * conversion
            total_volume += volume
    
    # Objectifs à maximiser
    f1 = total_profit  # Profit total
    f2 = total_weighted_conversion / total_volume  # Conversion globale
    
    return f1, f2

def create_individual(majoration_rates: np.ndarray, params: Dict) -> Individual:
    """Crée un individu avec évaluation des objectifs"""
    objectives = evaluate_objectives(majoration_rates, params)
    return Individual(
        majoration_rates=majoration_rates,
        objectives=objectives,
        rank=0,
        crowding_distance=0.0
    )

def initialize_population(population_size: int, params: Dict) -> List[Individual]:
    """Initialise la population avec des contraintes de bornes"""
    population = []
    
    for _ in range(population_size):
        majoration_rates = np.zeros((params['n_conv'], params['n_profit']))
        
        for j in range(params['n_conv']):
            for k in range(params['n_profit']):
                min_bound, max_bound = get_bounds(j, k, params)
                majoration_rates[j, k] = np.random.uniform(min_bound, max_bound)
        
        individual = create_individual(majoration_rates.flatten(), params)
        population.append(individual)
    
    return population

def dominates(ind1: Individual, ind2: Individual) -> bool:
    """Test de dominance de Pareto"""
    f1_1, f2_1 = ind1.objectives
    f1_2, f2_2 = ind2.objectives
    
    # Pour maximisation des deux objectifs
    return (f1_1 >= f1_2 and f2_1 >= f2_2) and (f1_1 > f1_2 or f2_1 > f2_2)

def fast_non_dominated_sort(population: List[Individual]) -> List[List[Individual]]:
    """
    Tri rapide non-dominé O(MN²)
    Algorithme de Deb et al. (2002)
    """
    fronts = [[]]
    
    # Ajouter des attributs temporaires aux individus
    for p in population:
        p.domination_count = 0
        p.dominated_solutions = []
        
        for q in population:
            if dominates(p, q):
                p.dominated_solutions.append(q)
            elif dominates(q, p):
                p.domination_count += 1
        
        if p.domination_count == 0:
            p.rank = 0
            fronts[0].append(p)
    
    i = 0
    while len(fronts[i]) > 0:
        next_front = []
        for p in fronts[i]:
            for q in p.dominated_solutions:
                q.domination_count -= 1
                if q.domination_count == 0:
                    q.rank = i + 1
                    next_front.append(q)
        i += 1
        fronts.append(next_front)
    
    return fronts[:-1]  # Enlever le dernier front vide

def calculate_crowding_distance(front: List[Individual]):
    """
    Calcul de la distance de crowding
    Algorithme de Deb et al. (2002)
    """
    if len(front) <= 2:
        for individual in front:
            individual.crowding_distance = float('inf')
        return
    
    # Initialiser toutes les distances à 0
    for individual in front:
        individual.crowding_distance = 0.0
    
    # Pour chaque objectif
    for obj_idx in range(2):  # 2 objectifs
        # Trier par objectif
        front.sort(key=lambda x: x.objectives[obj_idx], reverse=True)
        
        # Points extrêmes ont une distance infinie
        front[0].crowding_distance = float('inf')
        front[-1].crowding_distance = float('inf')
        
        # Normalisation
        obj_range = front[0].objectives[obj_idx] - front[-1].objectives[obj_idx]
        if obj_range == 0:
            continue
        
        # Calculer les distances
        for i in range(1, len(front) - 1):
            distance = (front[i-1].objectives[obj_idx] - front[i+1].objectives[obj_idx]) / obj_range
            front[i].crowding_distance += distance

def tournament_selection(population: List[Individual]) -> Individual:
    """Sélection par tournoi avec rang et distance de crowding"""
    candidate1 = random.choice(population)
    candidate2 = random.choice(population)
    
    # Comparer selon NSGA-II
    if candidate1.rank < candidate2.rank:
        return candidate1
    elif candidate1.rank > candidate2.rank:
        return candidate2
    else:
        # Même rang, utiliser la distance de crowding
        return candidate1 if candidate1.crowding_distance > candidate2.crowding_distance else candidate2

def sbx_crossover(parent1: Individual, parent2: Individual, crossover_prob: float, 
                 eta_c: float, params: Dict) -> Tuple[Individual, Individual]:
    """Croisement SBX (Simulated Binary Crossover)"""
    if random.random() > crossover_prob:
        return parent1, parent2
    
    child1_genes = np.copy(parent1.majoration_rates)
    child2_genes = np.copy(parent2.majoration_rates)
    
    for i in range(len(child1_genes)):
        if random.random() <= 0.5:
            j = i // params['n_profit']
            k = i % params['n_profit']
            
            min_bound, max_bound = get_bounds(j, k, params)
            
            y1, y2 = child1_genes[i], child2_genes[i]
            
            if abs(y1 - y2) > 1e-14:
                if y1 > y2:
                    y1, y2 = y2, y1
                
                beta = 1.0 + 2.0 * (y1 - min_bound) / (y2 - y1)
                alpha = 2.0 - beta ** -(eta_c + 1.0)
                
                if random.random() <= 1.0 / alpha:
                    betaq = (random.random() * alpha) ** (1.0 / (eta_c + 1.0))
                else:
                    betaq = (1.0 / (2.0 - random.random() * alpha)) ** (1.0 / (eta_c + 1.0))
                
                c1 = 0.5 * ((y1 + y2) - betaq * (y2 - y1))
                
                beta = 1.0 + 2.0 * (max_bound - y2) / (y2 - y1)
                alpha = 2.0 - beta ** -(eta_c + 1.0)
                
                if random.random() <= 1.0 / alpha:
                    betaq = (random.random() * alpha) ** (1.0 / (eta_c + 1.0))
                else:
                    betaq = (1.0 / (2.0 - random.random() * alpha)) ** (1.0 / (eta_c + 1.0))
                
                c2 = 0.5 * ((y1 + y2) + betaq * (y2 - y1))
                
                c1 = np.clip(c1, min_bound, max_bound)
                c2 = np.clip(c2, min_bound, max_bound)
                
                if random.random() <= 0.5:
                    child1_genes[i] = c2
                    child2_genes[i] = c1
                else:
                    child1_genes[i] = c1
                    child2_genes[i] = c2
    
    child1 = create_individual(child1_genes, params)
    child2 = create_individual(child2_genes, params)
    
    return child1, child2

def polynomial_mutation(individual: Individual, mutation_prob: float, eta_m: float, 
                       params: Dict) -> Individual:
    """Mutation polynomiale"""
    mutated_genes = np.copy(individual.majoration_rates)
    
    for i in range(len(mutated_genes)):
        if random.random() <= mutation_prob:
            j = i // params['n_profit']
            k = i % params['n_profit']
            
            min_bound, max_bound = get_bounds(j, k, params)
            
            y = mutated_genes[i]
            delta1 = (y - min_bound) / (max_bound - min_bound)
            delta2 = (max_bound - y) / (max_bound - min_bound)
            
            rnd = random.random()
            mut_pow = 1.0 / (eta_m + 1.0)
            
            if rnd <= 0.5:
                xy = 1.0 - delta1
                val = 2.0 * rnd + (1.0 - 2.0 * rnd) * (xy ** (eta_m + 1.0))
                deltaq = val ** mut_pow - 1.0
            else:
                xy = 1.0 - delta2
                val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * (xy ** (eta_m + 1.0))
                deltaq = 1.0 - val ** mut_pow
            
            y = y + deltaq * (max_bound - min_bound)
            y = np.clip(y, min_bound, max_bound)
            mutated_genes[i] = y
    
    return create_individual(mutated_genes, params)

def nsga2_optimize(population_size: int = 100, max_generations: int = 500, 
                  crossover_prob: float = 0.8, eta_c: float = 15, eta_m: float = 20,
                  params: Dict = None) -> Tuple[List[Individual], Dict]:
    """
    Algorithme NSGA-II principal
    Retourne le front de Pareto et les statistiques
    """
    if params is None:
        params = setup_problem_parameters()
    
    # Probabilité de mutation
    mutation_prob = 1.0 / (params['n_conv'] * params['n_profit'])
    
    # Initialisation
    population = initialize_population(population_size, params)
    
    # Statistiques
    stats = {
        'best_profit': [],
        'best_conversion': [],
        'average_profit': [],
        'average_conversion': []
    }
    
    for generation in range(max_generations):
        # Créer la descendance
        offspring = []
        
        while len(offspring) < population_size:
            parent1 = tournament_selection(population)
            parent2 = tournament_selection(population)
            
            child1, child2 = sbx_crossover(parent1, parent2, crossover_prob, eta_c, params)
            child1 = polynomial_mutation(child1, mutation_prob, eta_m, params)
            child2 = polynomial_mutation(child2, mutation_prob, eta_m, params)
            
            offspring.extend([child1, child2])
        
        offspring = offspring[:population_size]
        
        # Combiner population et descendance
        combined_population = population + offspring
        
        # Tri non-dominé rapide
        fronts = fast_non_dominated_sort(combined_population)
        
        # Nouvelle population
        new_population = []
        front_idx = 0
        
        while len(new_population) + len(fronts[front_idx]) <= population_size:
            calculate_crowding_distance(fronts[front_idx])
            new_population.extend(fronts[front_idx])
            front_idx += 1
        
        # Compléter avec le front suivant si nécessaire
        if len(new_population) < population_size:
            calculate_crowding_distance(fronts[front_idx])
            fronts[front_idx].sort(key=lambda x: x.crowding_distance, reverse=True)
            remaining = population_size - len(new_population)
            new_population.extend(fronts[front_idx][:remaining])
        
        population = new_population
        
        # Statistiques
        profits = [ind.objectives[0] for ind in population]
        conversions = [ind.objectives[1] for ind in population]
        
        stats['best_profit'].append(max(profits))
        stats['best_conversion'].append(max(conversions))
        stats['average_profit'].append(np.mean(profits))
        stats['average_conversion'].append(np.mean(conversions))
        
        if generation % 50 == 0:
            print(f"Génération {generation}: Meilleur profit = {max(profits):.2f}, Meilleure conversion = {max(conversions):.4f}")
    
    # Retourner le front de Pareto (premier front)
    final_fronts = fast_non_dominated_sort(population)
    pareto_front = final_fronts[0]
    
    return pareto_front, stats

def analyze_results(pareto_front: List[Individual], params: Dict) -> Individual:
    """Analyse des résultats d'optimisation"""
    print(f"\n=== ANALYSE DES RÉSULTATS ===")
    print(f"Taille du front de Pareto: {len(pareto_front)}")
    
    # Statistiques du front de Pareto
    profits = [ind.objectives[0] for ind in pareto_front]
    conversions = [ind.objectives[1] for ind in pareto_front]
    
    print(f"\nProfit:")
    print(f"  Min: {min(profits):.2f}")
    print(f"  Max: {max(profits):.2f}")
    print(f"  Moyenne: {np.mean(profits):.2f}")
    
    print(f"\nTaux de conversion:")
    print(f"  Min: {min(conversions):.4f}")
    print(f"  Max: {max(conversions):.4f}")
    print(f"  Moyenne: {np.mean(conversions):.4f}")
    
    # Analyser les taux de majoration par type de segment
    best_solution = max(pareto_front, key=lambda x: x.objectives[0])  # Meilleur profit
    
    print(f"\n=== SOLUTION OPTIMALE (Meilleur profit) ===")
    
    segment_stats = {seg_type: [] for seg_type in SegmentType}
    
    majoration_matrix = best_solution.majoration_rates.reshape(params['n_conv'], params['n_profit'])
    
    for j in range(params['n_conv']):
        for k in range(params['n_profit']):
            seg_type = params['segment_types'][j, k]
            majoration = majoration_matrix[j, k]
            segment_stats[seg_type].append(majoration)
    
    for seg_type, majorations in segment_stats.items():
        if majorations:
            print(f"\nSegment {seg_type.value}:")
            print(f"  Nombre: {len(majorations)}")
            print(f"  Majoration moyenne: {np.mean(majorations):.3f}")
            print(f"  Majoration min-max: [{min(majorations):.3f}, {max(majorations):.3f}]")
    
    return best_solution

def plot_results(pareto_front: List[Individual], stats: Dict, best_solution: Individual, params: Dict):
    """Visualisation des résultats"""
    plt.figure(figsize=(15, 5))
    
    # Front de Pareto
    plt.subplot(1, 3, 1)
    profits = [ind.objectives[0] for ind in pareto_front]
    conversions = [ind.objectives[1] for ind in pareto_front]
    plt.scatter(profits, conversions, c='red', alpha=0.7)
    plt.xlabel('Profit Total')
    plt.ylabel('Taux de Conversion Global')
    plt.title('Front de Pareto')
    plt.grid(True)
    
    # Évolution du profit
    plt.subplot(1, 3, 2)
    plt.plot(stats['best_profit'], label='Meilleur', color='red')
    plt.plot(stats['average_profit'], label='Moyen', color='blue')
    plt.xlabel('Génération')
    plt.ylabel('Profit')
    plt.title('Évolution du Profit')
    plt.legend()
    plt.grid(True)
    
    # Évolution de la conversion
    plt.subplot(1, 3, 3)
    plt.plot(stats['best_conversion'], label='Meilleure', color='red')
    plt.plot(stats['average_conversion'], label='Moyenne', color='blue')
    plt.xlabel('Génération')
    plt.ylabel('Taux de Conversion')
    plt.title('Évolution de la Conversion')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()

def main():
    """Fonction principale"""
    print("=== OPTIMISATION NSGA-II DES TAUX DE MAJORATION D'ASSURANCE ===")
    print("Basé sur: Deb, K. et al. (2002) NSGA-II: IEEE Trans. Evolutionary Computation")
    
    # Initialiser les paramètres
    params = setup_problem_parameters()
    
    # Afficher la classification des segments
    print(f"\nClassification des segments (seuils: Conv≥{params['theta_C']:.2f}, Rent≥{params['theta_R']:.3f}):")
    type_counts = {}
    for j in range(params['n_conv']):
        for k in range(params['n_profit']):
            seg_type = params['segment_types'][j, k]
            type_counts[seg_type.value] = type_counts.get(seg_type.value, 0) + 1
    
    for seg_type, count in type_counts.items():
        print(f"  Segment {seg_type}: {count} combinaisons")
    
    # Lancer l'optimisation
    print("\nDémarrage de l'optimisation NSGA-II...")
    pareto_front, stats = nsga2_optimize(params=params)
    
    # Analyser les résultats
    best_solution = analyze_results(pareto_front, params)
    
    # Visualisation
    plot_results(pareto_front, stats, best_solution, params)
    
    print(f"\n=== MATRICE DES TAUX DE MAJORATION OPTIMAUX ===")
    print("Lignes = Segments de conversion, Colonnes = Segments de rentabilité")
    print(f"Matrice {params['n_conv']}x{params['n_profit']}:")
    majoration_matrix = best_solution.majoration_rates.reshape(params['n_conv'], params['n_profit'])
    print(np.round(majoration_matrix, 3))

if __name__ == "__main__":
    main()
