import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from mpl_toolkits.mplot3d import Axes3D

# Paramètres fixes
coef_max = 0.7
rows, cols = 10, 20
i_vals = np.arange(1, rows + 1)
j_vals = np.arange(1, cols + 1)
i_grid, j_grid = np.meshgrid(i_vals, j_vals, indexing='ij')

# Création de la figure interactive
fig = plt.figure(figsize=(12, 7))
ax = fig.add_subplot(111, projection='3d')
plt.subplots_adjust(bottom=0.25)

# Fonction de calcul
def compute_C(alpha, beta):
    return coef_max * (i_grid / 10)*alpha * (j_grid / 20)*beta

# Valeurs initiales
alpha0 = 0.6
beta0 = 1.0
C = compute_C(alpha0, beta0)
surf = ax.plot_surface(i_grid, j_grid, C, cmap='viridis')
ax.set_xlabel('Conversion Group (i)')
ax.set_ylabel('ELR Group (j)')
ax.set_zlabel('C(i,j)')
ax.set_title('Effet de alpha et beta sur C(i,j)')

# Ajout des sliders
ax_alpha = plt.axes([0.15, 0.1, 0.65, 0.03])
ax_beta = plt.axes([0.15, 0.05, 0.65, 0.03])
slider_alpha = Slider(ax_alpha, 'Alpha (Conversion)', 0.1, 2.0, valinit=alpha0)
slider_beta = Slider(ax_beta, 'Beta (ELR)', 0.1, 2.0, valinit=beta0)

# Fonction de mise à jour
def update(val):
    ax.clear()
    alpha = slider_alpha.val
    beta = slider_beta.val
    C = compute_C(alpha, beta)
    ax.plot_surface(i_grid, j_grid, C, cmap='viridis')
    ax.set_xlabel('Conversion Group (i)')
    ax.set_ylabel('ELR Group (j)')
    ax.set_zlabel('C(i,j)')
    ax.set_title(f'Surface C(i,j) – alpha={alpha:.2f}, beta={beta:.2f}')
    fig.canvas.draw_idle()

slider_alpha.on_changed(update)
slider_beta.on_changed(update)

plt.show()
