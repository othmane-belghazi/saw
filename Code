import pandas as pd
import numpy as np
from ortools.linear_solver import pywraplp
import matplotlib.pyplot as plt
import seaborn as sns

# Configuration pour des graphiques propres
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = [12, 8]

# ==============================================================================
# BLOC 1 : GÉNÉRATION DE DONNÉES (Simulation de ton environnement)
# ==============================================================================
print("--- 1. GÉNÉRATION DES DONNÉES ---")

np.random.seed(42)
n_devis = 500

# A. BASE PORTEFEUILLE (Historique pour caler les ELR)
activites = ['Boulangerie', 'BTP', 'Consulting', 'Transport', 'Coiffure']
# On simule que le BTP et Transport sont risqués (sinistres élevés)
data_pf = []
for act in activites:
    risk_factor = 1.5 if act in ['BTP', 'Transport'] else 0.4
    for _ in range(200): # 200 contrats par activité
        prime = np.random.uniform(800, 3000)
        # Charge sinistre aléatoire (Lognormale pour simuler la queue de distribution)
        charge = np.random.lognormal(mean=np.log(prime * risk_factor), sigma=1.0)
        data_pf.append({'activite': act, 'prime_acquise': prime, 'charge_sinistre': charge})

df_portefeuille = pd.DataFrame(data_pf)

# B. BASE DEVIS (Les nouvelles affaires à tarifer)
data_devis = {
    'id': range(n_devis),
    'activite': np.random.choice(activites, n_devis),
    'prime_initiale': np.random.uniform(800, 3000, n_devis),
    'proba_initiale': np.random.uniform(0.20, 0.40, n_devis) # Score EBM
}
df_devis = pd.DataFrame(data_devis)

print(f"Portefeuille : {len(df_portefeuille)} lignes | Devis à traiter : {len(df_devis)}")


# ==============================================================================
# BLOC 2 : MOTEUR ACTUARIEL (Calcul des coûts et bornes)
# ==============================================================================
print("\n--- 2. CALCULS ACTUARIELS ---")

# 1. Calcul des ELR par activité sur le portefeuille
elr_table = df_portefeuille.groupby('activite')[['prime_acquise', 'charge_sinistre']].sum().reset_index()
elr_table['elr_ref'] = elr_table['charge_sinistre'] / elr_table['prime_acquise']

# 2. Projection sur les devis
df_model = df_devis.merge(elr_table[['activite', 'elr_ref']], on='activite', how='left')

# 3. Calcul du COÛT TECHNIQUE (La constante cruciale)
# C'est ce que le client coûte en moyenne, peu importe le prix de vente
df_model['cout_technique'] = df_model['prime_initiale'] * df_model['elr_ref']

# 4. Définition des Bornes de majoration (Règles Métier)
def get_bounds(elr):
    if elr < 0.40: return 0.00, 0.02   # Bons risques : Hausse faible (0-2%)
    elif elr < 0.80: return 0.02, 0.05 # Risques moyens : Hausse standard (2-5%)
    else: return 0.05, 0.15            # Mauvais risques : Assainissement (5-15%)

bounds = df_model['elr_ref'].apply(get_bounds)
df_model['min_h'] = [b[0] for b in bounds]
df_model['max_h'] = [b[1] for b in bounds]

print(df_model[['id', 'activite', 'prime_initiale', 'elr_ref', 'min_h', 'max_h']].head())


# ==============================================================================
# BLOC 3 : PRÉPARATION & OPTIMISATION (OR-TOOLS)
# ==============================================================================
print("\n--- 3. OPTIMISATION (MAXIMISATION MARGE) ---")

# A. Génération des Scénarios Discrets
def predict_elasticity(proba_base, hausse):
    # Simulation: -1.2 d'élasticité (Pour 10% de hausse, la proba baisse de 12% relatifs)
    impact = 1 - (1.2 * hausse)
    return max(0, proba_base * impact)

scenarios = []
for idx, row in df_model.iterrows():
    # On crée 5 points de test entre min et max
    steps = np.linspace(row['min_h'], row['max_h'], 5)
    steps = np.unique(steps) # Évite doublons si min=max
    
    for hausse in steps:
        prime_new = row['prime_initiale'] * (1 + hausse)
        proba_new = predict_elasticity(row['proba_initiale'], hausse)
        
        # --- CŒUR DU SYSTÈME : La Marge Espérée ---
        # (Prix Vendu - Coût Fixe) * Probabilité
        marge_esp = (prime_new - row['cout_technique']) * proba_new
        
        scenarios.append({
            'id': row['id'],
            'prime_base': row['prime_initiale'],
            'activite': row['activite'],
            'elr': row['elr_ref'],
            'hausse': hausse,
            'proba_new': proba_new,
            'prime_new': prime_new,
            'marge_esperee': marge_esp
        })

df_scen = pd.DataFrame(scenarios)

# B. Solveur
solver = pywraplp.Solver.CreateSolver('SCIP')
if not solver: raise Exception("Solveur introuvable")

x = {} # Variables binaires
for i in df_scen.index:
    x[i] = solver.BoolVar(f'x_{i}')

# Contrainte 1 : Unicité (1 prix par devis)
for d_id, group in df_scen.groupby('id'):
    solver.Add(solver.Sum([x[i] for i in group.index]) == 1)

# Contrainte 2 : Rétention Volume (> 90% du volume contrats initial)
vol_init = df_model['proba_initiale'].sum()
solver.Add(solver.Sum([df_scen.loc[i, 'proba_new'] * x[i] for i in df_scen.index]) >= 0.90 * vol_init)

# Contrainte 3 : Majoration Moyenne (Entre 3.8% et 4.5% pondéré Prime)
sum_primes = df_model['prime_initiale'].sum()
weighted_sum = solver.Sum([df_scen.loc[i, 'prime_base'] * df_scen.loc[i, 'hausse'] * x[i] for i in df_scen.index])
solver.Add(weighted_sum >= 0.038 * sum_primes)
solver.Add(weighted_sum <= 0.045 * sum_primes)

# OBJECTIF : Max Marge
solver.Maximize(solver.Sum([df_scen.loc[i, 'marge_esperee'] * x[i] for i in df_scen.index]))

status = solver.Solve()

# ==============================================================================
# BLOC 4 : ANALYSE ET VISUALISATION
# ==============================================================================
if status == pywraplp.Solver.OPTIMAL:
    print(">>> SOLUTION OPTIMALE TROUVÉE !\n")
    
    # Récupération des résultats
    selected_indices = [i for i in x if x[i].solution_value() > 0.5]
    res = df_scen.loc[selected_indices].copy()
    
    # KPIs
    avg_increase = (res['prime_base'] * res['hausse']).sum() / res['prime_base'].sum()
    retention_rate = res['proba_new'].sum() / vol_init
    total_margin = res['marge_esperee'].sum()
    
    # Marge Initiale (pour comparer)
    # Marge si on ne faisait rien (Hausse 0)
    # On simule grossièrement la marge initiale avec les probas initiales
    margin_init = ((df_model['prime_initiale'] - df_model['cout_technique']) * df_model['proba_initiale']).sum()
    
    print(f"KPIs GLOBAUX :")
    print(f"- Majoration Moyenne : {avg_increase:.2%}")
    print(f"- Rétention Volume   : {retention_rate:.1%}")
    print(f"- Gain de Marge      : +{(total_margin - margin_init):,.0f} € (vs scénario plat)")

    # --- VISUALISATION ---
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    plt.subplots_adjust(hspace=0.3)

    # Graphique 1 : Distribution des hausses
    sns.histplot(data=res, x='hausse', bins=15, kde=True, color='skyblue', ax=axes[0, 0])
    axes[0, 0].set_title('Distribution des Majorations Appliquées')
    axes[0, 0].set_xlabel('Taux de hausse')
    axes[0, 0].axvline(avg_increase, color='red', linestyle='--', label=f'Moyenne: {avg_increase:.1%}')
    axes[0, 0].legend()

    # Graphique 2 : Stratégie par Activité (Boxplot)
    # Montre que les activités pourries (ELR haut) prennent cher
    sns.boxplot(data=res, x='activite', y='hausse', palette="Set2", ax=axes[0, 1])
    axes[0, 1].set_title('Stratégie Tarifaire par Activité')
    axes[0, 1].set_ylabel('Hausse appliquée')

    # Graphique 3 : Cohérence ELR vs Hausse (Scatter)
    # On veut voir une corrélation positive : Plus l'ELR est haut, plus la hausse est haute
    sns.scatterplot(data=res, x='elr', y='hausse', hue='activite', size='prime_base', sizes=(20, 200), ax=axes[1, 0])
    axes[1, 0].set_title('Corrélation : Qualité du Risque (ELR) vs Hausse')
    axes[1, 0].set_xlabel('ELR (Expected Loss Ratio)')
    axes[1, 0].set_ylabel('Hausse appliquée')
    # Zone d'assainissement
    axes[1, 0].axvspan(1.0, res['elr'].max(), color='red', alpha=0.1, label='Zone Déficitaire')

    # Graphique 4 : Impact Volume vs Marge (Barplot)
    # On compare la répartition du volume avant/après (somme des probas)
    vol_per_act_before = df_model.groupby('activite')['proba_initiale'].sum()
    vol_per_act_after = res.groupby('activite')['proba_new'].sum()
    
    comp_df = pd.DataFrame({'Avant': vol_per_act_before, 'Après': vol_per_act_after}).reset_index()
    comp_df = comp_df.melt(id_vars='activite', var_name='Scenario', value_name='Volume Attendu')
    
    sns.barplot(data=comp_df, x='activite', y='Volume Attendu', hue='Scenario', ax=axes[1, 1])
    axes[1, 1].set_title('Impact sur le Volume (Contrats signés attendus)')
    
    plt.show()

else:
    print("Pas de solution optimale trouvée. Vérifiez les contraintes.")
