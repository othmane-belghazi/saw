import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

##############################
#      UTILITAIRES G√âN√âRAUX  #
##############################

def segment(series: pd.Series, n: int, method: str = "quantile") -> pd.Series:
    """Retourne le num√©ro de segment 0..n-1 pour chaque valeur de la s√©rie."""
    if method == "quantile":
        return pd.qcut(series, n, labels=False, duplicates="drop")
    elif method == "equal-width":
        return pd.cut(series, n, labels=False, include_lowest=True)
    else:
        raise ValueError("M√©thode inconnue : 'quantile' ou 'equal-width'.")


def build_matrix(
    df: pd.DataFrame,
    n_elr: int,
    n_conv: int,
    method: str,
    alpha: float,
    beta: float,
    smooth: bool,
    n_full: int,
):
    """Construit la matrice de majoration.

    Param√®tres
    ----------
    df : DataFrame contenant les colonnes premium, loss, conversion (0-1)
    n_elr, n_conv : nombre de segments
    method : 'quantile' ou 'equal-width'
    alpha, beta : pond√©rations (exposants) ELR vs Conversion
    smooth : active la cr√©dibilit√© limited-fluctuation
    n_full : effectif de pleine cr√©dibilit√©

    Retourne (M, N, R, C) o√π :
    * M : DataFrame matrice major√©e et renormalis√©e (moyenne pond√©r√©e = 1)
    * N : DataFrame effectifs
    * R : DataFrame (n_elr,1) ‚Äì facteurs ELR
    * C : DataFrame (1,n_conv) ‚Äì facteurs Concr√©tisation
    """
    df = df.copy()

    # Segmentation
    df["elr_seg"] = segment(df["ELR"], n_elr, method)
    df["conv_seg"] = segment(df["conversion"], n_conv, method)

    # Effectifs
    N = df.pivot_table(
        index="elr_seg", columns="conv_seg", values="premium", aggfunc="count", fill_value=0
    ).astype(int)

    # ELR moyens par segment + portefeuille
    ELR_i = df.groupby("elr_seg").apply(lambda d: d["loss"].sum() / d["premium"].sum())
    ELR_port = df["loss"].sum() / df["premium"].sum()
    R = (ELR_i / ELR_port).values  # shape (n_elr,)

    # Concr√©tisation moyenne par segment + portefeuille
    Conv_j = df.groupby("conv_seg")["conversion"].mean()
    Conv_port = df["conversion"].mean()
    C = (Conv_j / Conv_port).values  # shape (n_conv,)

    # Matrice brute (puissances alpha / beta)
    m_brut = np.power.outer(R, np.ones_like(C)) ** alpha * np.power.outer(np.ones_like(R), C) ** beta

    # Normalisation neutre
    K_norm = (m_brut * N.values).sum() / N.values.sum()
    M = m_brut / K_norm

    # Cr√©dibilit√© Limited-Fluctuation
    if smooth:
        Z = np.minimum(1.0, np.sqrt(N.values / n_full))
        M = 1 + Z * (M - 1)
        # renormalise apr√®s lissage
        K_norm2 = (M * N.values).sum() / N.values.sum()
        M /= K_norm2

    # Conversions DataFrames pour display
    M_df = pd.DataFrame(M, index=N.index, columns=N.columns)
    R_df = pd.DataFrame(R, index=N.index, columns=["R_i"])
    C_df = pd.DataFrame(C, index=["C_j"], columns=N.columns)

    return M_df, N, R_df, C_df


##############################
#       APPLICATION UI       #
##############################

def main():
    st.set_page_config(
        page_title="Matrice Majoration ‚Äì Cas pratique",
        layout="wide",
    )
    st.title("üß© Cas pratique : Construction interactive de la matrice de majoration")

    with st.sidebar:
        st.header("Param√®tres")
        uploaded = st.file_uploader("Donn√©es CSV (facultatif)")
        n_elr = st.slider("Nb segments ELR", 5, 40, 20)
        n_conv = st.slider("Nb segments Concr√©tisation", 5, 20, 10)
        method = st.selectbox("D√©coupage", ["quantile", "equal-width"])
        st.markdown("---")
        st.subheader("Pond√©rations Œ± / Œ≤")
        alpha = st.slider("Poids ELR (Œ±)", 0.0, 2.0, 1.0, 0.05)
        beta = st.slider("Poids Concr√©tisation (Œ≤)", 0.0, 2.0, 1.0, 0.05)
        st.markdown("---")
        smooth = st.checkbox("Activer cr√©dibilit√© Limited-Fluctuation", value=True)
        n_full = st.number_input("Effectif pleine cr√©dibilit√© N_F", 50, 10_000, 1_000, 50)
        st.markdown("---")
        st.caption("Si aucun fichier n'est fourni, un jeu simul√© de 15 000 expositions est g√©n√©r√©.")

    # Import / simulation donn√©es
    if uploaded is not None:
        df = pd.read_csv(uploaded)
    else:
        rng = np.random.default_rng(2025)
        n = 15_000
        premium = rng.uniform(150, 600, n)
        loss_ratio = rng.beta(2.5, 5, n)
        loss = premium * loss_ratio
        conversion = rng.beta(2, 2, n)  # moyenne 0.5
        df = pd.DataFrame({"premium": premium, "loss": loss, "conversion": conversion})

    # Assure coh√©rence ELR
    df["ELR"] = df["loss"] / df["premium"].replace(0, np.nan)

    # Construction matrice
    M, N, R_df, C_df = build_matrix(
        df, n_elr, n_conv, method, alpha, beta, smooth, n_full
    )

    ##############################
    #       VISUALISATIONS       #
    ##############################

    colM, colSide = st.columns((4, 1))

    with colM:
        st.subheader("Matrice de majoration normalis√©e")
        fig, ax = plt.subplots(figsize=(8, 6))
        sns.heatmap(M, cmap="RdYlGn", center=1, linewidths=0.3, ax=ax)
        ax.set_xlabel("Segment Concr√©tisation j")
        ax.set_ylabel("Segment ELR i")
        st.pyplot(fig)

    with colSide:
        st.metric("Moyenne pond√©r√©e", f"{(M.values*N.values).sum()/N.values.sum():.4f}")
        st.dataframe(R_df.style.format({"R_i": "{:.3f}"}), height=300)
        st.dataframe(C_df.style.format("{:.3f}"))

    ##############################
    #     T√âL√âCHARGEMENTS        #
    ##############################

    st.markdown("---")
    csv_M = M.to_csv().encode("utf-8")
    st.download_button("üì• T√©l√©charger matrice (CSV)", csv_M, "matrix_majoration.csv", "text/csv")
    csv_N = N.to_csv().encode("utf-8")
    st.download_button("üì• T√©l√©charger effectifs (CSV)", csv_N, "effectifs.csv", "text/csv")


if _name_ == "_main_":
    main()
